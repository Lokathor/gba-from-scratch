<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GBA From Scratch With Ferris</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Open Graph tags-->
        <meta name="og:site_name" content="GBA From Scratch With Ferris" />
        <meta name="og:title" content="GBA From Scratch With Ferris" />
        <meta name="og:description" content="" />
        
        <!-- Twitter meta tags -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@lokathor" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ex1.html"><strong aria-hidden="true">1.</strong> A Basic Executable</a></li><li class="chapter-item expanded "><a href="ex2.html"><strong aria-hidden="true">2.</strong> User Input</a></li><li class="chapter-item expanded "><a href="ex3.html"><strong aria-hidden="true">3.</strong> Objects / Sprites</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GBA From Scratch With Ferris</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lokathor/gba-from-scratch" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a series about how to program for the Game Boy Advance (GBA) using the Rust programming language.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The work in this project is licensed as follows:</p>
<ul>
<li>Rust code: <code>Zlib OR Apache-2.0 OR MIT</code></li>
<li>All other content (linker scripts, book text, etc): <code>CC0-1.0</code></li>
</ul>
<h2 id="support-the-project"><a class="header" href="#support-the-project">Support The Project</a></h2>
<p>If you'd like to support the book you can sign up to be a <a href="https://github.com/sponsors/Lokathor">Github Sponsor</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Let's program some stuff to run on the GBA.</p>
<h2 id="basic-compilation"><a class="header" href="#basic-compilation">Basic Compilation</a></h2>
<p>As usual with any new Rust project we'll need a <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "gba_from_scratch"
version = "0.1.0"
edition = "2021"
</code></pre>
<p>And we want some sort of program to run so let's make an example called <code>ex1.rs</code> in the <code>examples/</code> directory.
It can just be a classic "Hello, World" type program to start.</p>
<pre><pre class="playground"><code class="language-rust">// examples/ex1.rs

fn main() {
  println!("hello");
}</code></pre></pre>
<p>Since we're not running the compiler on the GBA itself, then we'll need to "cross-compile" our program.
It's called "cross compilation" when you build a program for some system <em>other</em> than the system that you're running the compiler on.
The system running the compiler is called the "host" system, and the system you're building for is called the "target" system.
In our case, the host system can be basically anything that can run a Rust toolchain.
I've had success on Windows, Linux, and Mac, there's no big difficulties.</p>
<p>To do a cross compile, we pass <a href="https://doc.rust-lang.org/cargo/commands/cargo-build.html#compilation-options">--target</a> to <code>cargo</code>.
If we look up the <a href="https://en.wikipedia.org/wiki/Game_Boy_Advance">Game Boy Advance</a> on wikipedia, we can see that it has an <a href="https://en.wikipedia.org/wiki/ARM7#ARM7TDMI">ARM7TDMI</a> CPU.
The "ARM7T" part means that it uses the "ARMv4T" CPU architecture.
Now we go the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Platform Support</a> page and use "ctrl+F" to look for "ARMv4T".
We can see three(-ish) entries that might(?) be what we want.</p>
<ul>
<li><code>armv4t-none-eabi</code></li>
<li><code>armv4t-unknown-linux-gnueabi</code></li>
<li><code>thumbv4t-none-eabi</code></li>
</ul>
<p>This is the part where my "teach like you're telling a story" style breaks down a bit.
What should happen next is that we pick the <code>thumbv4t-none-eabi</code> target.
Except there's not an easy to find document that tells you this step that I can just link to and have you read a few lines.
The shortest version of the full explanation is something like "Many ARM CPUs support two code 'states', and one of them is called '<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">thumb</a>', and that's the better default on the GBA."
We can certainly talk more about that later, but for now you just gotta go with it.</p>
<p>Let's see what happens when we pass <code>--target thumbv4t-none-eabi</code> as part of a call to <code>cargo</code>:</p>
<pre><code>&gt;cargo build --example ex1 --target thumbv4t-none-eabi
   Compiling gba_from_scratch v0.1.0 (D:\dev\gba-from-scratch)
error[E0463]: can't find crate for `std`
  |
  = note: the `thumbv4t-none-eabi` target may not be installed
  = help: consider downloading the target with `rustup target add thumbv4t-none-eabi`
  = help: consider building the standard library from source with `cargo build -Zbuild-std`

error: requires `sized` lang_item

For more information about this error, try `rustc --explain E0463`.
error: could not compile `gba_from_scratch` (lib) due to 2 previous errors
</code></pre>
<p>Well we seem to have already configured something wrong, somehow.
The trouble with a wrong project configuration is that the compiler can't always guess what you <em>meant</em> to do.
This means that the error message suggestions might be helpful, but they also might lead you down the wrong path.</p>
<p>One suggested way to fix the problem is to add the <code>thumbv4t-none-eabi</code> target with <code>rustup</code>.
It seems pretty low risk to just try installing that, so let's see.</p>
<pre><code>&gt;rustup target add thumbv4t-none-eabi
error: toolchain 'nightly-x86_64-pc-windows-msvc' does not contain component 'rust-std' for target 'thumbv4t-none-eabi'; did you mean 'thumbv6m-none-eabi'?
note: not all platforms have the standard library pre-compiled: https://doc.rust-lang.org/nightly/rustc/platform-support.html
help: consider using `cargo build -Z build-std` instead
</code></pre>
<p>Ah, dang.
If we double check the Platform Support page we might see that <code>thumbv4t-none-eabi</code> is in the "Tier 3" section.
Tier 3 targets don't have a standard library available in <code>rustup</code>.</p>
<p>How about this <code>build-std</code> thing?
The <code>-Z</code> flags are all unstable flags, so we can check the <a href="https://doc.rust-lang.org/cargo/reference/unstable.html">unstable section</a> of the cargo manual.
Looks like <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std">build-std</a> lets us build our own standard library.
We're going to need Nightly rust, so set that up how you want if you need to.
You can use <code>rustup default nightly</code> (which sets the <em>system global</em> default), or you can use a <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">toolchain file</a> if you want to use Nightly on just this one project.
Once we've set for Nightly use, we need to get the <code>rust-src</code> component from <code>rustup</code> too.</p>
<pre><code>rustup default nightly
rustup component add rust-src
</code></pre>
<p>Okay let's try again</p>
<pre><code>&gt; cargo build --example ex1 --target thumbv4t-none-eabi -Z build-std
   Compiling compiler_builtins v0.1.89
   Compiling core v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/core)
   Compiling libc v0.2.140
   Compiling cc v1.0.77
   Compiling memchr v2.5.0
   Compiling std v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/std)
   Compiling unwind v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/unwind)
   Compiling rustc-std-workspace-core v1.99.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/rustc-std-workspace-core)
   Compiling alloc v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/alloc)
   Compiling cfg-if v1.0.0
   Compiling adler v1.0.2
   Compiling rustc-demangle v0.1.21
   Compiling rustc-std-workspace-alloc v1.99.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/rustc-std-workspace-alloc)
   Compiling panic_abort v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/panic_abort)
   Compiling panic_unwind v0.0.0 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/panic_unwind)
   Compiling gimli v0.26.2
   Compiling miniz_oxide v0.5.3
   Compiling hashbrown v0.12.3
   Compiling object v0.29.0
   Compiling std_detect v0.1.5 (/Users/dg/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/stdarch/crates/std_detect)
error[E0432]: unresolved import `alloc::sync`
 --&gt; /Users/dg/.cargo/registry/src/index.crates.io-6f17d22bba15001f/gimli-0.26.2/src/read/dwarf.rs:2:12
  |
2 | use alloc::sync::Arc;
  |            ^^^^ could not find `sync` in `alloc`

For more information about this error, try `rustc --explain E0432`.
error: could not compile `gimli` (lib) due to previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p>Whoa... that's way too much.
We didn't mean for all of that to happen.
Let's check that cargo manual again.
Ah, it says we need to pass an argument to our command line argument if we don't want as much stuff to be build</p>
<pre><code>&gt; cargo build --example ex1 --target thumbv4t-none-eabi -Z build-std=core 
   Compiling gba_from_scratch v0.1.0 (/Users/dg/gba-from-scratch)
error[E0463]: can't find crate for `std`
  |
  = note: the `thumbv4t-none-eabi` target may not support the standard library
  = note: `std` is required by `gba_from_scratch` because it does not declare `#![no_std]`
  = help: consider building the standard library from source with `cargo build -Zbuild-std`

For more information about this error, try `rustc --explain E0463`.
error: could not compile `gba_from_scratch` (lib) due to previous error
</code></pre>
<p>That's different from before at least.
Well, we told to to only build <code>core</code> and not <code>std</code>, and then it said we couldn't use <code>std</code>.
Makes sense.
Lets change the example.</p>
<pre><code class="language-rs">// ex1.rs
#![no_std]

fn main() {
  println!("hello");
}
</code></pre>
<p>And we need to fix our <code>lib.rs</code> to also be <code>no_std</code>.
It doesn't do anything else for now, it's just blank beyond being no_std.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
#![no_std]
<span class="boring">}</span></code></pre></pre>
<p>Now rust-analyzer is telling me we can't use println in our example.
Also, we're missing a <code>#[panic_handler]</code>.
Here's the error.</p>
<pre><code>&gt; cargo build --example ex1 --target thumbv4t-none-eabi -Z build-std=core
   Compiling gba_from_scratch v0.1.0 (/Users/dg/gba-from-scratch)
error: cannot find macro `println` in this scope
 --&gt; examples/ex1.rs:4:3
  |
4 |   println!("hello");
  |   ^^^^^^^

error: `#[panic_handler]` function required, but not found

error: could not compile `gba_from_scratch` (example "ex1") due to 2 previous errors
</code></pre>
<p>Well, we can comment out the <code>println!</code>.
For the panic handler, we go to the <a href="https://doc.rust-lang.org/reference/attributes.html">Attributes</a> part of the rust reference.
That links us to <a href="https://doc.rust-lang.org/reference/runtime.html#the-panic_handler-attribute">panic_handler</a>, which sets what function gets called in event of panic.</p>
<pre><pre class="playground"><code class="language-rust">// ex1.rs
#![no_std]

fn main() {
  //
}

#[panic_handler]
fn panic_handler(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}</code></pre></pre>
<p>Now we get a new, <em>different</em> error when we try to build:</p>
<pre><code>&gt; cargo build --example ex1 --target thumbv4t-none-eabi -Z build-std=core
   Compiling gba_from_scratch v0.1.0 (/Users/dg/gba-from-scratch)
error: requires `start` lang_item

error: could not compile `gba_from_scratch` (example "ex1") due to previous error
</code></pre>
<p>Alright so what's this <code>start</code> lang item deal?
Well it has to do with the operating system being able to run your executable.
The details aren't important for us, because there's no operating system on the GBA.
Instead of trying to work with the <code>start</code> thing, we'll declare our program as <code>#![no_main]</code>.
This prevents the compiler from automatically generating the <code>main</code> entry fn, which is what's looking to call that start fn.
Note that this generated <code>main</code> fn is <em>separate</em> from the <code>main</code> fn that we normally think of as being the start of the program.
Because, as always, programmers are very good at naming things.</p>
<pre><pre class="playground"><code class="language-rust">// ex1.rs
#![no_std]
#![no_main]

fn main() {
  //
}

#[panic_handler]
fn panic_handler(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}</code></pre></pre>
<p>Okay let's try another build.</p>
<pre><code>&gt; cargo build --example ex1 --target thumbv4t-none-eabi -Z build-std=core
   Compiling gba_from_scratch v0.1.0 (/Users/dg/gba-from-scratch)
warning: function `main` is never used
 --&gt; examples/ex1.rs:4:4
  |
4 | fn main() {
  |    ^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: `gba_from_scratch` (example "ex1") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
</code></pre>
<p>Okay.
It builds.</p>
<h2 id="using-mgba"><a class="header" href="#using-mgba">Using mGBA</a></h2>
<p>Let's see if it works I guess.
Personally I like to use <a href="https://mgba.io/">mGBA</a> as my emulator of choice, but any GBA emulator should be fine.
If you're on Windows then your executable will be called <code>mgba.exe</code> by default, and if you're on Mac or Linux you'll get both <code>mgba</code> (no UI) and <code>mgba-qt</code> (has a menu bar and such around the video frame).
On my Windows machine I just made a copy of <code>mgba.exe</code> that's called <code>mgba-qt.exe</code> so that both names work on all of my devices.</p>
<pre><code>&gt; mgba target/thumbv4t-none-eabi/debug/examples/ex1
</code></pre>
<p>The emulator starts and then... shows a dialog box.
"An error occurred." says the box's title bar.
"Could not load game. Are you sure it's in the correct format?"
Well, sorry mgba, but we're not sure it's in the correct format.
In fact, we're pretty sure it's <em>not</em> the correct format right now.
I guess we'll have to inspect the compilation output.</p>
<h2 id="arm-binutils"><a class="header" href="#arm-binutils">ARM Binutils</a></h2>
<p>If we go to ARM's developer website we can fine the <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">ARM Toolchain Downloads</a> page.
This lets us download the tools for working with executables for the <code>arm-none-eabi</code> family of targets.
This includes our <code>thumbv4t</code> program, as well as other variants of ARM code.
You can get it from their website, or if you're on a Linux you can probably get it from your package manager.</p>
<p>The binutils package for a target family has many individual tools.
The ones we'll be using will all be named <code>arm-none-eabi-</code> to start, to distinguish them from the same tool for other targets.
So if we want to use "objdump" we call it with <code>arm-none-eabi-objdump</code> and so on.
That's exactly what we want to use right now.
We pass the name of the compiled executable, and then whichever other options we want.
For now let's look at the <code>--section-headers</code></p>
<pre><code>&gt; arm-none-eabi-objdump target/thumbv4t-none-eabi/debug/examples/ex1 --section-headers

target/thumbv4t-none-eabi/debug/examples/ex1:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .debug_abbrev 000000f4  00000000  00000000  00000094  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  1 .debug_info   000005a6  00000000  00000000  00000188  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  2 .debug_aranges 00000020  00000000  00000000  0000072e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  3 .debug_str    00000495  00000000  00000000  0000074e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_pubnames 000000c0  00000000  00000000  00000be3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_pubtypes 00000364  00000000  00000000  00000ca3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .ARM.attributes 00000030  00000000  00000000  00001007  2**0
                  CONTENTS, READONLY
  7 .debug_frame  00000028  00000000  00000000  00001038  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00000042  00000000  00000000  00001060  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .comment      00000013  00000000  00000000  000010a2  2**0
                  CONTENTS, READONLY
</code></pre>
<p>There's a few columns of note:</p>
<ul>
<li><code>Size</code> is the number of bytes for the section.</li>
<li><code>VMA</code> is the Virtual Memory Address. On the GBA this means the intended address when the main program is running. All of our data starts in ROM, and some of it we will copy into RAM just after boot. When a section is intended to be copied into RAM, it will have a VMA separate from the LMA.</li>
<li><code>LMA</code> is the Logical Memory Address. On the GBA this means the address in ROM.</li>
</ul>
<p>Which means... according to the chart... none of this data would end up in the ROM?
I guess that means that, if we extracted our raw program from the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> container file that the compiler uses, we would end up with a totally blank ROM.
That certainly doesn't sound like what mgba would call the "correct format".</p>
<h2 id="linker-scripts"><a class="header" href="#linker-scripts">Linker Scripts</a></h2>
<p>What's wrong is that we need to adjust the <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.
That link goes to the documentation for the binutils linker (called <code>ld</code>), and technically we're actually using the linker that ships with the compiler (called <code>rust-lld</code>).
<code>rust-lld</code> is the Rust version of <code>lld</code>, which is LLVM's linker that's intended to be a "drop in" replacement for GNU's <code>ld</code>.
Both linkers use a linker script system, and they both even use the same linker script format.
I tried to find an in depth manual for <code>lld</code> specifically, but all I could find was the top level "man page" explanations.
Referring to the the GNU <code>ld</code> manual will have to do.</p>
<p>You don't have to read the whole manual, the short story goes like this: linkers take one or more "object" files and "link" them into a single "executable" file.
The linker script is what guides the linker in exactly what to do.
If you don't say what script to use then the linker will use a default linker script that it keeps wherever.
When the target is a "normal" target like Windows or Mac then using a default linker script is just fine.
When the target is something a little more esoteric, like most embedded devices, including the GBA, then the default won't be good enough.
We'll have to write our own script and make the linker use that.</p>
<p>One complexity here is that the linker script to use is an argument passed to the linker.
And the way you pass args to the linker is that you tell <code>rustc</code> to do it.
Except with <code>cargo build</code> there's no way to tell <code>rustc</code> an extra argument.
We could use <code>cargo rustc</code>, but it's a pain to have to remember an alternate command.
As much as possible we'd like <code>cargo build</code> to work.
We could use a <code>build.rs</code> file to pass an arg to the linker, but making a build script just to pass one argument seems like maybe overkill.
Probably we should just set it as part of our the <code>RUSTFLAGS</code> environment variable.
The catch with <code>RUSTFLAGS</code> is that any time you change it you have to build <em>the entire crate graph</em> again.
We want to "write it down" (so to speak) and have it automatically be the same every time.
This can be done with a <a href="https://doc.rust-lang.org/cargo/reference/config.html#configuration">cargo configuration</a> file.</p>
<p>First let's make a blank <code>normal_boot.ld</code> file in a <code>linker_scripts/</code> folder.
Then in the <code>.cargo</code> folder we fill in <code>config.toml</code></p>
<pre><code class="language-toml"># .cargo/config.toml

[target.thumbv4t-none-eabi]
rustflags = ["-Clink-arg=-Tlinker_scripts/normal_boot.ld"]
</code></pre>
<p>while we're at it, we can even set a default target (which is used when we don't specify <code>--target</code>, and we can configure for <code>build-std</code> to be automatically be used, all in the same file.</p>
<pre><code class="language-toml"># .cargo/config.toml

[unstable]
build-std = ["core"]

[build]
target = "thumbv4t-none-eabi"

[target.thumbv4t-none-eabi]
rustflags = ["-Clink-arg=-Tlinker_scripts/normal_boot.ld"]
</code></pre>
<p>Great, let's try it out</p>
<pre><code>&gt; cargo build --example ex1
warning: function `main` is never used
 --&gt; examples\ex1.rs:4:4
  |
4 | fn main() {
  |    ^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: `gba_from_scratch` (example "ex1") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
</code></pre>
<p>Cool.
It's a lot less to type, and we're ready to fill in our linker script.</p>
<p>Our linker script is called <code>normal_boot.ld</code> because there's two ways for the GBA to boot up.
One of them is the "normal" style with a program running off of the game pak.
The other is "multiboot" where the GBA can download a program over the link cable.
Since we might want to do multiboot some day, we might as well give our linker script a specific name to start with.
Once things are set up we won't really have to think about it on a regular basis, so it's fine.</p>
<p>There's three things we'll have to concern ourselves with:</p>
<ul>
<li>The <a href="https://sourceware.org/binutils/docs/ld/Entry-Point.html">entry point</a></li>
<li>The <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">memory</a> locations</li>
<li>The <a href="https://sourceware.org/binutils/docs/ld/SECTIONS.html">sections</a></li>
</ul>
<p>Picking an entry point is easy, it's just the name of a symbol.
The traditional entry point name is just <code>_start</code>, so we'll go with that.</p>
<pre><code class="language-ld">ENTRY(_start)
</code></pre>
<p>Having an entry point set <em>doesn't really matter</em> for running the program on actual GBA hardware.
Still when the entry point ends up at one of the usual address values, it helps the heuristic system mgba uses to determine if it should run our program as a normal game or a multiboot game, so it's not entirely useless.</p>
<p>Which brings us to the memory portion.</p>
<p>The GBA has three main chunks of memory: Read-Only Memory (ROM), Internal Work RAM (IWRAM), and External Work RAM (EWRAM).
We can cover more of the fine differences later, for now it's enough to write them down into our linker script.
For each one we have to specify the base address and the size in bytes.</p>
<pre><code class="language-ld">MEMORY {
  ewram (w!x) : ORIGIN = 0x2000000, LENGTH = 256K
  iwram (w!x) : ORIGIN = 0x3000000, LENGTH = 32K
  rom (rx)    : ORIGIN = 0x8000000, LENGTH = 32M
}
</code></pre>
<p>Finally, we have to tell the linker which <em>output</em> section to assign all of the <em>input</em> sections it finds.
This uses a glob-matching sort of system.
We specify an output section that we want to have created, and then in the braces for it we list matchers that are checked against each input section the linker sees.
When an input section fits one of the matchers, it goes with that output section.</p>
<p>Program code is supposed to end up in the <code>.text</code> section, so we can start with just that.</p>
<pre><code class="language-ld">SECTIONS {
  .text : {
    *(.text .text.*);
  } &gt;rom
}
</code></pre>
<p>Here we've got one matcher listed, <code>*(.text .text.*);</code>.
The <code>*</code> at the start means it applies to any input file.
We could limit what files it applies to, if we wanted, but generally we shouldn't.
Inside the parenthesis is a space separated list of globs.
We've got two: <code>.text</code> and <code>.text.*</code>.
The first is for the exact match <code>.text</code>, and the second is for anything that starts with <code>.text.</code>.
The convention for section names is to start with a <code>.</code>, and they can't have spaces.
Rust will default to having every function in its own section, all with the prefix <code>.text.</code>.
Unused code can only be removed one entire input section at a time, so having every function in a distinct input section keeps our output as small as possible.</p>
<p>The <code>&gt;rom</code> part after tha braces allocates the entire output section into the <code>rom</code> memory that we declared before.</p>
<p>All together, we've got this:</p>
<pre><code class="language-ld">/* normal_boot.ld */
/* THIS LINKER SCRIPT FILE IS RELEASED TO THE PUBLIC DOMAIN (SPDX: CC0-1.0) */

ENTRY(_start)

MEMORY {
  ewram (w!x) : ORIGIN = 0x2000000, LENGTH = 256K
  iwram (w!x) : ORIGIN = 0x3000000, LENGTH = 32K
  rom (rx)    : ORIGIN = 0x8000000, LENGTH = 32M
}

SECTIONS {
  .text : {
    *(.text._start);
    *(.text .text.*);
  } &gt;rom
}
</code></pre>
<p>This isn't a complete and "final" linker script, but for now it's enough to let us proceed.</p>
<p>If we rebuild the program right now we still won't get anything in the output <code>.text</code> section.
Remember that dead code warning we keep getting on our <code>main</code> function?
Nothing in our program ever calls <code>main</code>, and it's not public for outsiders to call, so it gets discarded during linking.
Since no code can call <code>main</code> then no code can panic either, and the <code>panic_handler</code> function gets removed as well.
We end up with nothing at all.</p>
<h2 id="writing-a-_start"><a class="header" href="#writing-a-_start">Writing A <code>_start</code></a></h2>
<p>We need to add some code to our progam so that there will be something to output.
Might as well define the <code>_start</code> function.</p>
<p><code>_start</code> doesn't work like a normal function.
The way the very start of the GBA's ROM works is special.
When the GBA first boots the BIOS (which is part of the GBA itself, not part of our ROM) takes control.
It and plays the boot animation and sound that you're probably familiar with, then does a checksum on our ROM's header data.
If the checksum passes the BIOS jumps control to <code>0x0800_0000</code> (the start of ROM).
That's where our <code>_start</code> will be.
The first instruction can be "anything" but immediateley after that is the rest of the header data.
That means that in practice the very first instruction of <code>_start</code> has to be a jump <em>past</em> the rest of the header data, since the header data isn't executable code.</p>
<p>Sticking non-executable data into the middle of a function isn't something that the compiler is really capable of dealing with, so we'll have to take direct control of the situation.
We could do this using either <a href="https://doc.rust-lang.org/core/arch/macro.global_asm.html">global_assembly!</a> or a <a href="https://github.com/rust-lang/rust/issues/90957">#[naked]</a> function.
One might think that we should pick the Stable option (global assembly), over the Nightly option (a naked function).
However, naked functions are basically much easier to work with.
Since using <code>build-std</code> means that we have to use Nightly anyway, it's not that bad to also use naked functions as well.
If naked functions were the very last thing that required us to use Nightly we could move to global assembly instead.</p>
<p>At the top of <code>ex1.rs</code> we need to add <code>#![feature(naked_functions)]</code>.</p>
<p>Then we add our <code>_start</code> function.
In addition to marking it as <code>#[naked]</code>, we also mark it <code>#[no_mangle]</code>.
We need to use <code>#[instruction_set(arm::a32)]</code> as well.
This is part of that arm/thumb thing from before.
Because the BIOS jumps to the start of the ROM with the CPU in a32 mode, our function must be encoded appropriately.
Since <code>_start</code> has got to specifically at the very start of the ROM we'll use <code>#[link_section = ".text._start"]</code> to assign our function a specific section name we can use in our linker script.
Since <code>_start</code> is going to be "called" by the outside world we have to assign it the <code>extern "C"</code> ABI.
Since it should never return we will mark the return type as <code>-&gt; !</code>.
So far it all looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ex1.rs

#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = ".text._start"]
unsafe extern "C" fn _start() -&gt; ! {
  todo!()
}
<span class="boring">}</span></code></pre></pre>
<p>Inside of the <code>_start</code> function, because it's a naked function, we must put an <code>asm!</code> block as the only statement.
Our assembly will be very simple for now.
Let's look at it on its own.</p>
<pre><code class="language-arm">b 1f
.space 0xE0
1:
b 1b
</code></pre>
<p>In the first line we branch (<code>b</code>) to the label <code>1</code> that is "forward" from the instruction (<code>1f</code>).</p>
<p>Then with <code>.space</code> we put 0xE0 blank bytes.
This is called a "directive", it doesn't emit an instruction directly, instead it tells the assembler to do a special action.
We can tell it's a directive because it has a <code>.</code> at the beginning.
The blank space is where the header data can go when we need to fill it in.
mgba doesn't check the header, so during development it's fine to leave the header blank.
We can always fix the header data after compilation using a special tool called <code>gbafix</code> when we need to.</p>
<p>The <code>1:</code> is a label.
We know it's a label because it ends with <code>:</code>.
Unlike with function names, a label can be just a number.
In fact, it's <em>preferred</em> to only use numberic labels whenever possible.
When a non-numeric label is defined more than once it causes problems (that's why function names are mangled by default, and we had to use <code>no_mangle</code>).
When a numeric label is defined more than once, all instances of that label can co-exist just fine.
When you jump to a numbered label (forward or back), it just jumps to the closest instance of that number (in whichever direction).
Note that a label <em>can</em> have something else on the same line following the <code>:</code>.
Usually a label will be on a line of its own so that it stands out a little more in the code, but that's just a code style thing.
Something can follow a label on the same line as well.
If a label is on a line of its own, the label "points to" the next line that has a non-label thing on it.
You can also have more than one label point at the same line, if necessary.</p>
<p>Finally, our second actual instruction is that we want to branch backward to the label <code>1</code>.
Since that <code>1</code> label points at the branch itself, this instruction causes an infinite loop.
The same as if we'd written <code>loop {}</code> in rust.</p>
<p>At the end of our assembly we have to put <code>options(noreturn)</code>.
That's just part of how <code>#[naked]</code> functions work.
So when we put it all together we get this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ex1.rs

#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = ".text._start"]
unsafe extern "C" fn _start() -&gt; ! {
  core::arch::asm! {
    "b 1f",
    ".space 0xE0",
    "1:",
    "b 1b",
    options(noreturn)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>And we also want to adjust the linker script.
Since <code>_start</code> is now in <code>.text._start</code>, we'll put a special matcher for that to make sure it stays at the start of the ROM, no matter what order the linker sees our files in.</p>
<pre><code class="language-ld">/* normal_boot.ld */

SECTIONS {
  .text : {
    *(.text._start);
    *(.text .text.*);
  } &gt;rom
}
</code></pre>
<p>And after all of this, we can build our example and see that something shows up in the <code>.text</code> section of the executable.</p>
<pre><code>&gt; cargo build --example ex1 &amp;&amp; arm-none-eabi-objdump target/thumbv4t-none-eabi/debug/examples/ex1 --section-headers
   Compiling core v0.0.0 (C:\Users\Daniel\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core)
   Compiling rustc-std-workspace-core v1.99.0 (C:\Users\Daniel\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\rustc-std-workspace-core)
   Compiling compiler_builtins v0.1.89
   Compiling gba_from_scratch v0.1.0 (D:\dev\gba-from-scratch)
    Finished dev [unoptimized + debuginfo] target(s) in 9.98s

target/thumbv4t-none-eabi/debug/examples/ex1:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000e6  08000000  08000000  00010000  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  080000e8  080000e8  000100e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .debug_abbrev 0000010a  00000000  00000000  000100f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  3 .debug_info   000005b7  00000000  00000000  00010202  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_aranges 00000028  00000000  00000000  000107b9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_ranges 00000018  00000000  00000000  000107e1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_str    0000049c  00000000  00000000  000107f9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_pubnames 000000cb  00000000  00000000  00010c95  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_pubtypes 00000364  00000000  00000000  00010d60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .ARM.attributes 00000030  00000000  00000000  000110c4  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000038  00000000  00000000  000110f4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   00000056  00000000  00000000  0001112c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .comment      00000013  00000000  00000000  00011182  2**0
                  CONTENTS, READONLY
</code></pre>
<p>I think we're ready to test the program.
Obviously we just use <code>cargo run</code> and...</p>
<pre><code>&gt; cargo run --example ex1
    Finished dev [unoptimized + debuginfo] target(s) in 0.08s
     Running `target\thumbv4t-none-eabi\debug\examples\ex1`
error: could not execute process `target\thumbv4t-none-eabi\debug\examples\ex1` (never executed)

Caused by:
  %1 is not a valid Win32 application. (os error 193)
</code></pre>
<p>Ah, right, Windows doesn't know how to run GBA programs, of course.</p>
<p>Instead, let's adjust the <code>.cargo/config.toml</code> to set a "runner" value in our target confituration.
When we have a runner set, <code>cargo run</code> will call the runner program and pass the program we picked as the first argument.</p>
<pre><code class="language-toml"># .cargo/config.toml 

[target.thumbv4t-none-eabi]
rustflags = ["-Clink-arg=-Tlinker_scripts/normal_boot.ld"]
runner = "mgba-qt" #remove the -qt part if you're on Windows!
</code></pre>
<p>And so we try again</p>
<pre><code>&gt; cargo run --example ex1
    Finished dev [unoptimized + debuginfo] target(s) in 0.08s
     Running `mgba-qt target\thumbv4t-none-eabi\debug\examples\ex1`
</code></pre>
<p>If everything is right so far, mGBA should launch and show a white screen.
Congrats, it didn't crash.</p>
<h2 id="checking-with-objdump"><a class="header" href="#checking-with-objdump">Checking With <code>objdump</code></a></h2>
<p>If we want to double check that our code is showing up in the executable properly we can even use <code>objdump</code> to check that.
If we pass <code>--disassemble</code> we can get a printout of the assembly.
There's a bunch of other options for how to configure that output too, so check the <code>--help</code> output to see what you can do.
I like to use <code>--demangle --architecture=armv4t --no-show-raw-insn -Mreg-names-std</code>, and you get output like this:</p>
<pre><code>&gt; arm-none-eabi-objdump target/thumbv4t-none-eabi/debug/examples/ex1 --disassemble --demangle --architecture=armv4t --no-show-raw-insn -Mreg-names-std

target/thumbv4t-none-eabi/debug/examples/ex1:     file format elf32-littlearm


Disassembly of section .text:

08000000 &lt;_start&gt;:
 8000000:       b       80000e4 &lt;_start+0xe4&gt;
        ...
 80000e4:       b       80000e4 &lt;_start+0xe4&gt;
 80000e8:       udf     #65006  ; 0xfdee
</code></pre>
<p>Disassembly is a tricky thing sometimes.
It's not always clear to the disassembler what is code and what's data.
Or when it should decode <code>a32</code> code (4 bytes each) or <code>t32</code> code (2 bytes each).
In this case, the disassembler did notice that enough bytes in a row are all zero, and it just cuts that from the output with a <code>...</code>.
That's cool, but it doesn't <em>always</em> work.
Every once in a while the disassembler will interpret things wrong and a chunk of the display will be nonsense.
It's kinda just how it goes, try not to worry if you see it happen.</p>
<p>Also, at the end of our function we can see there's an undefined instruction.
Those will happen sometimes at the end functions.
I'm unclear on why.
It doesn't seem to be for alignment, because going 4 bytes past <code>0x0800_00E8</code> to <code>0x0800_00EC</code> would make things <em>less</em> aligned.
Still, I guess it's not really a big deal when it happens.
We've got so much ROM space available that an occasional 2 or 4 bytes extra won't really break the bank.</p>
<h2 id="proving-our-program-is-doing-something"><a class="header" href="#proving-our-program-is-doing-something">Proving Our Program Is Doing Something</a></h2>
<p>It's all nice and well to see a white screen, but let's finish up this section by having our program do something, anything at all, which lets us see that we're really having an effect on the GBA.</p>
<p>The simplest thing to do would be to make the screen turn on black instead of white.
When the BIOS transfers control to our program a thing called the "forced blank" mode is active.
This makes the display draw all pixels as white.
If we turn off the forced blank bit we'll get a black screen instead.</p>
<p>All we have to do is add a few more lines of assembly to our <code>_start</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in `main` of ex1.rs

  core::arch::asm! {
    "b 1f",
    ".space 0xE0",
    "1:",
    "mov r0, #0x04000000",
    "mov r1, #0",
    "strh r1, [r0]",
    "2:",
    "b 2b",
    options(noreturn)
  }
<span class="boring">}</span></code></pre></pre>
<p>This part after the header data is what's new:</p>
<pre><code class="language-arm">mov r0, #0x04000000
mov r1, #0
strh r1, [r0]
</code></pre>
<p><code>mov</code> will "move" a value into a register.
This shares the usual assignment syntax of Rust and most other programming languages:
the destination register is on the left,
and the source data to move into that register is on the right.
So you could think of it being <em>similar</em> to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r0 = 0x04000000;
<span class="boring">}</span></code></pre></pre>
<p>The <code>#</code> means that the value is an "immediate" value.
It gets encoded into the instruction itself, so it doesn't have to "come from" anywhere else.
With LLVM's assembler it seems like actually putting the <code>#</code> before an immediate value is optional (that is: the program will compile the same without it),
but on some assemblers putting the <code>#</code> is required, so I'll be putting it in the tutorial code.</p>
<p>After we move values into <code>r0</code> and <code>r1</code> we have a <code>strh</code>.
This will "store(half)" the data in the first argument to the address in the second argument.
In other words, it writes the lower 16 bits of the register to the address, as if the address was a <code>*mut u16</code>.
The argument order for single loads and stores on ARM is that the address is always last, and in square brackets.
The square brackets make it fairly easy to spot when skimming through a big pile of assembly.</p>
<p>After doing that <code>strh</code> we have an "empty loop" like we had before, but just using the label <code>2</code> instead of <code>1</code> this time.</p>
<p>And if we turn on the program...</p>
<pre><code class="language-txt">cargo run --example ex1
</code></pre>
<p>Instead of a totally white screen, we'll see a totally black screen.
We've had <em>some effect</em> on the GBA.</p>
<p>Which is enough to call this article over.
In the next article we'll actually learn more details about what we just did,
as well as more details about how else we can affect the screen.</p>
<p><a href="https://github.com/Lokathor/gba-from-scratch/tree/b6dc1ca7c914f2e93d304c68b923208ccc48a92f">This</a> is the exact state of the repo when I finished this article.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-input"><a class="header" href="#user-input">User Input</a></h1>
<p>So far we can build a program that shows a white screen, or a program that shows a black screen.
As fascinating as this is, we can't even make the program switch from white to black while it's running.
That will be our goal for this part.</p>
<p>For this article we'll be mostly working on a new example: <code>ex2.rs</code></p>
<h2 id="memory-mapped-inputoutput-mmio"><a class="header" href="#memory-mapped-inputoutput-mmio">Memory Mapped Input/Output (MMIO)</a></h2>
<p>At the end of the last article I told you to put a mysterious bit of assembly into the program</p>
<pre><code class="language-arm">mov r0, #0x04000000
mov r1, #0
strh r1, [r0]
</code></pre>
<p>This "resets the forced blank bit", and that lets the display show the normal picture instead of all white.
At the moment our normal picture is all black, but soon it will be something else.</p>
<p>What's happening is called Memory Mapped Input/Output, or Memory Mapped IO, or even just MMIO.</p>
<p>The CPU only knows how to do math and access memory.
What "accessing memory" actually means is that a signal goes along a "bus".
The signal can be pushed out to other hardware ("store"), or be pulled in from the other hardware ("load").
When the signal's address points a memory device it's how we store data for later.
There's also other types of device too, things that don't just store data.
When the signal goes there, "other stuff" happens.</p>
<p>The address <code>0x04000000</code> connects to a part of the display system called the Display Control.
When we set the display control's bits to <code>0_u16</code> with our <code>strh</code> instruction, that includes the forced blank bit.
There's other bits too, which we'll get to soon.</p>
<p>All of the GBA's hardware is controlled via MMIO,
so most of this series will involve explaining MMIO address values and the correct way to set ths bits at each address.</p>
<p>Note that an MMIO address is <em>not</em> like normal memory:</p>
<ul>
<li>Sometimes an address will be read-only (writes are totally ignored) or write-only (reading produces garbage data).</li>
<li>Sometimes an address will allow both reads and writes, but what you read back will be something else from what you last wrote.</li>
<li>This is <em>not</em> the case with any of the GBA's MMIO, but on some other devices (eg: the NES) reading an MMIO location can be "destructive", changing the value just by reading it.</li>
</ul>
<h2 id="volatile-memory-access"><a class="header" href="#volatile-memory-access">Volatile Memory Access</a></h2>
<p>Normally the compiler will try to keep memory accesses to a minimum.
If it sees you read an address twice without a write in between, it'll (usually) only do the first read.
If you write to an address twice without a read in between it'll (usually) skip the first write.
I say "usually" because it depends on optimization level and such.
It's simple stuff, but it makes programs fast, and we want our programs fast.</p>
<p>However, when working with MMIO every single memory access has to happen <em>exactly</em> as we write it in our program.
If we're (for example) reading the address for the button data then <em>of course</em> we'd read it over and over without ever doing a write.
But we still need every single read to actually happen so we can get the newest button data.</p>
<p>To tell the compiler this, we use a "volatile" load or store instead of a normal load or store.
This is done with the <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.read_volatile">read_volatile</a> and <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.write_volatile">write_volatile</a> pointer methods.
But those are <code>unsafe</code> methods because the compiler naturally doesn't know if, for any given pointer, it's safe to just read or write some data.
Pointers can come from anywhere, they might be dangling, etc etc, all the normal problems with raw pointers.</p>
<p>Instead, we'll use the <a href="https://docs.rs/voladdress">voladdress</a> crate.
It's got some alternatives to just raw points that ease the volatile usage quite a bit.
I made it specifically to power the <code>gba</code> crate's MMIO, so we can be <em>fairly confident</em> that it'll be useful for writing GBA programs.</p>
<pre><code>&gt; cargo add voladdress
    Updating crates.io index
      Adding voladdress v1.3.0 to dependencies.
</code></pre>
<p>Now in our <code>lib.rs</code> we can declare <code>DISPCNT</code>.
That's the short name that <a href="https://problemkaputt.de/gbatek.htm">GBATEK</a> (the main GBA homebrew manual) and mGBA use for the display control.
In Rust terms it's a <a href="https://docs.rs/voladdress/latest/voladdress/struct.VolAddress.html">VolAddress</a> for a <code>u16</code> value.
It's safe to read or write, and it's located at <code>0x0400_0000</code> like we saw before.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

use voladdress::{Safe, VolAddress};

pub const DISPCNT: VolAddress&lt;u16, Safe, Safe&gt; =
  unsafe { VolAddress::new(0x0400_0000) };
<span class="boring">}</span></code></pre></pre>
<p>Now we can adjust the display control within Rust.
Neato.</p>
<h2 id="moving-_start-into-the-library"><a class="header" href="#moving-_start-into-the-library">Moving <code>_start</code> Into The Library</a></h2>
<p>When we made <code>ex1.rs</code> we put the <code>_start</code> function directly into the example file.
That's not a great long term plan.
We want to have a <code>_start</code> function that just does the correct startup "in the background", automatically.
We don't want to be thinking about it again with each new example we make.</p>
<p>So first let's copy the <code>_start</code> function into <code>lib.rs</code>.
This will require us to put <code>#![feature(naked_functions)]</code> at the top of <code>lib.rs</code>.
Again, we <em>could</em> use global assembly instead, but I think that global assembly is just a little worse than naked functions, and we're already on Nightly.</p>
<p>Now all of our examples moving forward will have the <code>_start</code> function (assuming they link in our library).
That's fine, except that right now <code>_start</code> doesn't have a way to call any function in our executable.</p>
<p>We're gonna rewrite <code>_start</code> to do whatever startup it needs and <em>then</em> we'll have it call another function.
If we pick an un-mangled name for the function that <code>_start</code> calls each executable we make will be able to make a function with that name and the linker will weave it all together just fine.
Since it's the conventional "beginning of the program" name let's use <code>main</code>.</p>
<p>First we update <code>_start</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = ".text._start"]
unsafe extern "C" fn _start() -&gt; ! {
  core::arch::asm! {
    "b 1f",
    ".space 0xE0",
    "1:",
    "ldr r12, =main",
    "bx r12",
    options(noreturn)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Our new assembly is this part:</p>
<pre><code class="language-arm">ldr r12, =main
bx r12
</code></pre>
<p>The first line, <code>ldr &lt;reg&gt;, =symbol</code>, is a special "pseudo instruction".
It looks like an instruction, but what the assembler actually outputs is a slight variation.
What will happen is that the assembler will insert a load operation for an address relative to this instruction, and then at that relative address the assembler will also insert the address of <code>main</code> itself.
This way we don't have to know where <code>main</code> is.
In fact we don't even have to have defined <code>main</code> at all.
That's good, because our library won't define <code>main</code> anyway.
As long as the final executable defines <code>main</code> <em>somewhere</em> the linker will patch it all together.</p>
<p>The second line <code>bx &lt;reg&gt;</code> is a "branch-exchange".
This is a special kind of branch that we have to use with ARMv4T when we want to switch between ARM code (a32) and Thumb code (t32).
It switches to the correct code mode as part of the jumping the program's execution to the new address.
The <code>_start</code> function <em>must</em> be written in a32 code, but most of the rest of the program, including <code>main</code>, could be written in either code type.
Since <code>main</code> might be a different code type from <code>_start</code> we use <code>bx</code> instead of the basic <code>b</code> instruction we've been using previously.
(note: there's a third type of branch on the GBA called <code>bl</code>, which we'll see eventually).</p>
<p>While <code>b</code> instruction jumped to a <em>label</em>, <code>bx</code> jumps to a <em>register</em>.
That's why we have to load <code>main</code> into <code>r12</code> before we can use <code>bx</code>.
I picked <code>r12</code> in this case just because the convention is that it's a "scratch" register.
With the C ABI the caller will never pass data through <code>r12</code>, and functions are allowed to modify <code>r12</code> without restoring the value before they return.</p>
<p>That's all that <code>_start</code> has to do for now.
Later it will have some setup work to do before calling <code>main</code>, but not yet.</p>
<h3 id="this-is-an-incomplete-start-function"><a class="header" href="#this-is-an-incomplete-start-function">This Is An Incomplete Start Function</a></h3>
<p><strong>NOTE:</strong> This <code>_start</code> function is "incomplete" in the sense that it doesn't initialize RAM.
This means that you can't use any static mutable data with non-zero initial values.
We're not doing that right now, so that's not a problem for us right now, and we'll get to that eventually.
But it is a non-obvious limitation worth mentioning.</p>
<h2 id="adding-main-to-ex2rs"><a class="header" href="#adding-main-to-ex2rs">Adding <code>main</code> To <code>ex2.rs</code></a></h2>
<p>Now in <code>ex2.rs</code> we need to have a <code>main</code> function that's <code>no_mangle</code>, <code>extern "C"</code>, and that doesn't ever return.</p>
<p>To begin, we'll make the actual body of <code>main</code> just do what we were doing before.
First write 0 to <code>DISPCNT</code>, and then do a <code>loop</code> forever.</p>
<pre><pre class="playground"><code class="language-rust">// ex2.rs
#![no_std]
#![no_main]

use gba_from_scratch::DISPCNT;

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  DISPCNT.write(0);
  loop {}
}

#[panic_handler]
fn panic_handler(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}</code></pre></pre>
<p>And if we run this in mGBA with <code>cargo run --example ex2</code> we see... actually we see a mostly black screen but with a white line on it.</p>
<p><img src="ex2-white-line.png" alt="ex2_white_line" /></p>
<p>That's... not what we expected?
That's not either of the types of screen that we got before.
Here's where things get kinda weird.
If we run our program in <code>--release</code> mode we <em>don't</em> see the line.</p>
<p>Let's look at the output of the compiler again with <code>objdump</code>.
In fact, now that we've got more than one example let's have a script to store that "use objdump" stuff.
I'm gonna make a <code>dump.bat</code>, but you can make <code>dump.sh</code> if you're on Mac or Linux.
It's just a few plain commands, no special scripting.</p>
<pre><code class="language-bat">cargo build --examples

arm-none-eabi-objdump target/thumbv4t-none-eabi/debug/examples/ex1 --section-headers --disassemble --demangle --architecture=armv4t --no-show-raw-insn -Mreg-names-std &gt;target/ex1.txt

arm-none-eabi-objdump target/thumbv4t-none-eabi/debug/examples/ex2 --section-headers --disassemble --demangle --architecture=armv4t --no-show-raw-insn -Mreg-names-std &gt;target/ex2.txt
</code></pre>
<p>Okay, and the <code>target/ex1.txt</code> file has about what we expect in it. A bunch of sections like we saw before and then.</p>
<pre><code class="language-txt">Disassembly of section .text:

08000000 &lt;_start&gt;:
 8000000:	b	80000e4 &lt;_start+0xe4&gt;
	...
 80000e4:	mov	r0, #67108864	; 0x4000000
 80000e8:	mov	r1, #0
 80000ec:	strh	r1, [r0]
 80000f0:	b	80000f0 &lt;_start+0xf0&gt;
 80000f4:	udf	#65006	; 0xfdee
</code></pre>
<p>Yep, just what we expected.</p>
<p>Let's see what's in <code>target/ex2.txt</code>, same basic thing, right?
Ah, wait, well there's 29 sections instead of 12.
That's probably fine, more debug info or something, probably?
Won't affect our code, I'm sure.</p>
<pre><code class="language-txt">Disassembly of section .text:

08000000 &lt;_start&gt;:
 8000000:	b	80000e4 &lt;_start+0xe4&gt;
	...
 80000e4:	ldr	r12, [pc, #4]	; 80000f0 &lt;_start+0xf0&gt;
 80000e8:	bx	r12
 80000ec:	udf	#65006	; 0xfdee
 80000f0:	.word	0x08000115
</code></pre>
<p>Sure, what we expected...</p>
<pre><code class="language-txt">080000f4 &lt;voladdress::voladdress_::VolAddress&lt;T,R,voladdress::Safe&gt;::write&gt;:
 80000f4:	push	{r7, lr}
 80000f6:	sub	sp, #16
 80000f8:	str	r1, [sp, #4]
 80000fa:	str	r0, [sp, #8]
 80000fc:	add	r2, sp, #12
 80000fe:	strh	r1, [r2, #0]
 8000100:	bl	8000178 &lt;core::num::nonzero::NonZeroUsize::get&gt;
 8000104:	ldr	r1, [sp, #4]
 8000106:	bl	800012c &lt;core::ptr::write_volatile&gt;
 800010a:	add	sp, #16
 800010c:	pop	{r7}
 800010e:	pop	{r0}
 8000110:	mov	lr, r0
 8000112:	bx	lr
</code></pre>
<p>Oops.. that's... not a good way to write to a pointer.</p>
<pre><code class="language-txt">08000114 &lt;main&gt;:
 8000114:	movs	r0, #1
 8000116:	lsls	r0, r0, #26
 8000118:	movs	r1, #0
 800011a:	bl	80000f4 &lt;voladdress::voladdress_::VolAddress&lt;T,R,voladdress::Safe&gt;::write&gt;
 800011e:	b.n	8000120 &lt;main+0xc&gt;
 8000120:	b.n	8000120 &lt;main+0xc&gt;
</code></pre>
<p>Oh?</p>
<pre><code class="language-txt">08000122 &lt;rust_begin_unwind&gt;:
 8000122:	sub	sp, #4
 8000124:	str	r0, [sp, #0]
 8000126:	b.n	8000128 &lt;rust_begin_unwind+0x6&gt;
 8000128:	b.n	8000128 &lt;rust_begin_unwind+0x6&gt;
 800012a:	bmi.n	80000d6 &lt;_start+0xd6&gt;
</code></pre>
<p>Okay that one seems okay, I think?</p>
<pre><code class="language-txt">0800012c &lt;core::ptr::write_volatile&gt;:
 800012c:	push	{r7, lr}
 800012e:	sub	sp, #24
 8000130:	str	r0, [sp, #0]
 8000132:	movs	r2, r1
 8000134:	str	r2, [sp, #4]
 8000136:	str	r0, [sp, #12]
 8000138:	add	r0, sp, #16
 800013a:	strh	r1, [r0, #0]
 800013c:	movs	r0, #1
 800013e:	cmp	r0, #0
 8000140:	bne.n	8000154 &lt;core::ptr::write_volatile+0x28&gt;
 8000142:	b.n	8000144 &lt;core::ptr::write_volatile+0x18&gt;
 8000144:	ldr	r0, [sp, #4]
 8000146:	ldr	r1, [sp, #0]
 8000148:	strh	r0, [r1, #0]
 800014a:	add	sp, #24
 800014c:	pop	{r7}
 800014e:	pop	{r0}
 8000150:	mov	lr, r0
 8000152:	bx	lr
 8000154:	ldr	r0, [sp, #0]
 8000156:	str	r0, [sp, #8]
 8000158:	ldr	r0, [sp, #8]
 800015a:	str	r0, [sp, #20]
 800015c:	bl	8000180 &lt;core::intrinsics::is_aligned_and_not_null&gt;
 8000160:	cmp	r0, #0
 8000162:	bne.n	8000170 &lt;core::ptr::write_volatile+0x44&gt;
 8000164:	b.n	8000166 &lt;core::ptr::write_volatile+0x3a&gt;
 8000166:	ldr	r0, [pc, #12]	; (8000174 &lt;core::ptr::write_volatile+0x48&gt;)
 8000168:	movs	r1, #111	; 0x6f
 800016a:	bl	80002fc &lt;core::panicking::panic_nounwind&gt;
 800016e:	udf	#254	; 0xfe
 8000170:	b.n	8000144 &lt;core::ptr::write_volatile+0x18&gt;
 8000172:	nop			; (mov r8, r8)
 8000174:	.word	0x08000440
</code></pre>
<p>Oh... uh... oh no.
And there's more.
It goes on and on, but I think you get the joke at this point.</p>
<p>Yeah, <code>rustc</code> outputs <em>utter garbage</em> code without optimizations enabled.
Just, atrocious.
The only reason it's usable at all on your desktop is because modern computers are so fast.</p>
<p>Our best bet is to just turn on full optimizations for the debug profile.
This can be done in <code>Cargo.toml</code>.
In a new <code>profile.dev</code> section we set the <code>opt-level</code> to 3.</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 3
</code></pre>
<p>And rebuild / redump the program:</p>
<pre><code class="language-txt">Disassembly of section .text:

08000000 &lt;_start&gt;:
 8000000:	b	80000e4 &lt;_start+0xe4&gt;
	...
 80000e4:	ldr	r12, [pc, #4]	; 80000f0 &lt;_start+0xf0&gt;
 80000e8:	bx	r12
 80000ec:	udf	#65006	; 0xfdee
 80000f0:	.word	0x080000f5

080000f4 &lt;main&gt;:
 80000f4:	movs	r0, #1
 80000f6:	lsls	r0, r0, #26
 80000f8:	movs	r1, #0
 80000fa:	strh	r1, [r0, #0]
 80000fc:	b.n	80000fc &lt;main+0x8&gt;
</code></pre>
<p>That's it, that's our whole program once optimizations have been applied.
Now we don't get the white line.</p>
<p>Why did we get it before?
I don't know exactly.
Our <code>ex2</code> program "stops" on an infinite loop that's just as fast as the <code>ex1</code> version, even if it takes longer to get there.
I'd have thought that it wouldn't make a difference, but somehow it does.
Emulators are weird like that sometimes.</p>
<p>Oh, and speaking of weird stuff, while we're adjusting build configuration things, I found out about that undefined instruction thing.
Our good friend Scott wrote in (so to speak) and suggested trying <code>-Ztrap-unreachable=no</code> in RUSTFLAGS.</p>
<p>So we just add it in the <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.thumbv4t-none-eabi]
rustflags = ["-Ztrap-unreachable=no", "-Clink-arg=-Tlinker_scripts/normal_boot.ld"]
runner = "mgba-qt"
</code></pre>
<p>and rebuild / redump again...</p>
<pre><code class="language-txt">Disassembly of section .text:

08000000 &lt;_start&gt;:
 8000000:	b	80000e4 &lt;_start+0xe4&gt;
	...
 80000e4:	ldr	r12, [pc]	; 80000ec &lt;_start+0xec&gt;
 80000e8:	bx	r12
 80000ec:	.word	0x080000f1

080000f0 &lt;main&gt;:
 80000f0:	movs	r0, #1
 80000f2:	lsls	r0, r0, #26
 80000f4:	movs	r1, #0
 80000f6:	strh	r1, [r0, #0]
 80000f8:	b.n	80000f8 &lt;main+0x8&gt;
</code></pre>
<p>The undefined instruction is gone!
Magical!
I guess the explanation is that LLVM is trying to add in a "guard" against code accidentally flowing past the end of the function.
When the CPU is made to execute and undefined instruction it causes a special kind of "interrupt" to happen.
We'll mostly talk about interrupts later, but for now let's just say that what LLVM is <em>expecting</em> is that the Operating System will handle the interrupt by killing the program (the undefined instruction "traps" your program).
We don't really have an OS on the GBA, we <em>are</em> the OS you might say.
Regardless of what you call it, that undefined instruction won't "trap" like LLVM thinks it will.
The undefined interrupt handler in the BIOS just returns and the device just keeps executing.
So that undefined instruction is purely a waste of space to us.</p>
<p>We might as well leave <code>-Ztrap-unreachable=no</code> set in our configuration.
The <code>-Z</code> part means that it's a Nightly flag, but we're on Nightly for other stuff already so it's fine.
If we have to be on Nightly for <code>build-std</code>, we might as well take advantage of the other extra flags we can.</p>
<h2 id="more-assembly-details"><a class="header" href="#more-assembly-details">More Assembly Details</a></h2>
<p>Let's quickly take another close look at our two functions so far.</p>
<p>First is <code>_start</code></p>
<pre><code class="language-arm">08000000 &lt;_start&gt;:
 8000000:	b	80000e4 &lt;_start+0xe4&gt;
	...
 80000e4:	ldr	r12, [pc]	; 80000ec &lt;_start+0xec&gt;
 80000e8:	bx	r12
 80000ec:	.word	0x080000f1
</code></pre>
<p>So the <code>ldr r12, =main</code> has become <code>ldr	r12, [pc]</code>.
The <code>pc</code> register is the "program counter".
That's storing the next address for the CPU to read and start doing an instruction.
The ARM7TDMI has a 3 stage CPU pipeline: Fetch, Decode, Execute.
The <code>pc</code> register will always be pointing <em>two instructions</em> ahead of what instruction is actually executing.
So by the time we're executing the <code>ldr</code>, the <code>pc</code> register is two instructions ahead on <code>.word	0x080000f1</code>.
The <code>.word</code> directive inserts a literal 4 byte value, in this case <code>0x080000f1</code>.
That's the address of <code>main</code>, +1.
The +1 part makes the address odd, which is how <code>bx</code> will know what code state to switch to.</p>
<p>So after we load an address into <code>r12</code>, we use <code>bx</code> to branch-exchange to that address.
The "exchange" part is because there's a register called the "current program status register".
This register holds several bit flags about the program's current status.
Importantly it has a T flag, which says if the CPU is running in thumb state or not.
A branch-exchange will "exchange" the lowest bit in the register holding the target address with the current value of the T flag.</p>
<ul>
<li>If the target address is odd then the T flag becomes set (the program will run as thumb code).</li>
<li>If the target address is even then the T flag becomes cleared (the program will run as arm code).</li>
</ul>
<p>And I know it's an "exchange", but the <em>previous</em> T value basically goes nowhere.
They just call it an exchange to give it a fancy name, I guess.</p>
<p>I hope that wasn't too much.
If not, don't worry.
It's not essential to understand the full details right away if you want to just keep going.</p>
<p>Let's look over at <code>main</code>.</p>
<pre><code class="language-arm">080000f0 &lt;main&gt;:
 80000f0:	movs	r0, #1
 80000f2:	lsls	r0, r0, #26
 80000f4:	movs	r1, #0
 80000f6:	strh	r1, [r0, #0]
 80000f8:	b.n	80000f8 &lt;main+0x8&gt;
</code></pre>
<p>Ah, here's something interesting.
Instead of <code>mov</code> we're doing <code>movs</code>, and instead of <code>lsl</code> (logical shift left) we're doing <code>lsls</code>.
When an instruction ends with <code>s</code> then it "sets the status flags".</p>
<ul>
<li><code>_start</code> is ARM code, and most all ARM instructions can choose to set the flags or not. We haven't set the status flags in our small amount of code so far.</li>
<li><code>main</code> is thumb code, and most all thumb instructions are forced to set the flags. This constraints how much you can reorder your instructions. Each operation that sets flags you care about has to come <em>just before</em> whatever the thing using those flags is.</li>
</ul>
<p>But let's notice something else.
We can see the addresses of each instruction, and in <code>_start</code> we can see each instruction is 4 bytes.
With <code>main</code> we can see that each instruction is just 2 bytes.
This is the advantage of using thumb code.
The program is significantly smaller.</p>
<p>In fact, the CPU has to access ROM over a 16-bit bus.
This means that if the CPU needs a 32-bit value (such as an ARM instruction) then it needs to do two reads in a row to get the complete data.
This means that when running programs out of ROM they actually run slower if they're ARM code.
The CPU will have to wait over and over as it tries to get each complete instruction just half an instruction at a time.
This is why we're having the default encoding for our program be thumb code.</p>
<p>Also, the way to get <code>0x0400_0000</code> into a register has changed:</p>
<ul>
<li>With ARM code we can <code>mov</code> the value directly as one instruction.</li>
<li>With thumb code we have to <code>movs</code> a 1 and then as a separate step we left shift it by 26 bits to get the right value.</li>
</ul>
<p>What's happening is that the ARM <code>mov</code> instruction <em>doesn't</em> encode the full litearal <code>0x0400_0000</code> within the instruction.
It's only a 32 bit instruction, so it can't store a 32 bit value and <em>also</em> the bits to declare <code>mov</code>.
Instead, it stores <code>mov</code> and a compressed form of the data: <code>1&lt;&lt;26</code>.
But thumb code is only 16 bits, so it can't even store that much.
Since each thumb instruction is only 2 bytes instead of 4, there's less bits to fit immediate values and do instruction variations and such.
This means that in a lot of cases an operation that's one ARM instruction will be more than one thumb instruction.
Because of this, thumb code vs ARM code is <em>not</em> as simple as "your program is half as big".
You get a significant savings on average, but the exact ratio depends on the program</p>
<p>We can see the disassembler is showing our <code>strh</code> as <code>strh	r1, [r0, #0]</code>.
This is saying "<code>r0</code> plus 0".
Actually any store or load can be "plus some immediate value", but when the modifier is plus 0 we don't need to write it.
In this case, the disassembler is just being a little silly in how it prints things.</p>
<p>Also, when we see <code>b.n	80000f8</code>, this <code>b.n</code> means "branch instruction with narrow encoding".
The explanation here is that in later versions of ARM there was a "thumb 2" introduced.
In thumb 2, some instructions will be encoded as one opcode (each of which is two bytes), but then other uses will be two opcodes.
The <code>.n</code> is the "narrow" encoding, meaning it's the one opcode version.
On the GBA we don't use thumb2 at all, but since the <code>objdump</code> program is designed to work with all versions of ARM it just prints this way.</p>
<h2 id="the-backdrop-color"><a class="header" href="#the-backdrop-color">The Backdrop Color</a></h2>
<p>The "backdrop" color is the color that's shown in a pixel if no background layer or object is visible in that pixel.
Right now when we turn off forced blank we see a black screen because the backdrop color is black.
If we were to change the backdrop color we'd see the whole screen filled with some other color.</p>
<p>First let's declare an MMIO for the backdrop color.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub const BACKDROP: VolAddress&lt;u16, Safe, Safe&gt; =
  unsafe { VolAddress::new(0x0500_0000) };
<span class="boring">}</span></code></pre></pre>
<p>Now let's update <code>ex2.rs</code> so that we set the backdrop color before we turn off forced blank.</p>
<pre><pre class="playground"><code class="language-rust">// in ex2.rs
use gba_from_scratch::{BACKDROP, DISPCNT};

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(0b11111);
  DISPCNT.write(0);
  loop {}
}</code></pre></pre>
<p>Let's look at that assembly:</p>
<pre><code class="language-arm">080000f0 &lt;main&gt;:
 80000f0:	movs	r0, #5
 80000f2:	lsls	r0, r0, #24
 80000f4:	movs	r1, #31
 80000f6:	strh	r1, [r0, #0]
 80000f8:	movs	r0, #1
 80000fa:	lsls	r0, r0, #26
 80000fc:	movs	r1, #0
 80000fe:	strh	r1, [r0, #0]
 8000100:	b.n	8000100 &lt;main+0x10&gt;
</code></pre>
<p>So first it gets the <code>BACKDROP</code> address in a register (5&lt;&lt;24), then the color value (31), then writes that, and the rest of the program is like we've seen before.
Makes sense.</p>
<p>We <em>could</em> also change the backdrop color after turning off forced blank if we wanted to.
However, by default it's best practice to only adjust the display when forced blank is on or when you know it's the vertical blank period.
Otherwise you can get accidental display artifacts on the screen.</p>
<p>If we run the program now we'll see a red screen.</p>
<p>The magic looking <code>0b11111</code> value is because the GBA has 5-bit per channel color.
A GBA color value is a <code>u16</code> with the channels going from low to high:</p>
<pre><code>0bX_BBBBB_GGGGG_RRRRR
</code></pre>
<p>So <code>0b11111</code> is "full red, no green or blue".</p>
<p>Using a raw <code>u16</code> isn't that great.
We'd probably like to have a little bit more meaning to the type so that it's clearer what's going on.
We can put names on our functions and magic values, things like that.</p>
<p>If we replace the <code>u16</code> in <code>BACKDROP</code> with a <code>repr(transparent)</code> wrapper type over an actual <code>u16</code> then things will be a lot better.
This is called using a "newtype", and we'll be doing it a lot.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub const BACKDROP: VolAddress&lt;Color, Safe, Safe&gt; =
  unsafe { VolAddress::new(0x0500_0000) };

#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct Color(pub u16);
impl Color {
  pub const RED: Self = Self::rgb(31, 0, 0);

  #[inline]
  #[must_use]
  pub const fn rgb(r: u16, g: u16, b: u16) -&gt; Self {
    Self(r | (g &lt;&lt; 5) | (b &lt;&lt; 10))
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Then we change <code>ex2.rs</code> to use our new Color type.</p>
<pre><pre class="playground"><code class="language-rust">use gba_from_scratch::{Color, BACKDROP, DISPCNT};

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(Color::RED);
  DISPCNT.write(0);
  loop {}
}</code></pre></pre>
<p>Practically self-documenting code at this point!</p>
<p>If we run the program again we can see a red screen too.
Let's double check our assembly to make sure we didn't kill performance somehow.</p>
<pre><code class="language-arm">080000f0 &lt;main&gt;:
 80000f0:	movs	r0, #5
 80000f2:	lsls	r0, r0, #24
 80000f4:	movs	r1, #31
 80000f6:	strh	r1, [r0, #0]
 80000f8:	movs	r0, #1
 80000fa:	lsls	r0, r0, #26
 80000fc:	movs	r1, #0
 80000fe:	strh	r1, [r0, #0]
 8000100:	b.n	8000100 &lt;main+0x10&gt;
</code></pre>
<p>Hey it's the <em>exact</em> same as before.
We've got a zero-runtime-cost abstraction, the promise of Rust is real!</p>
<h2 id="reading-the-buttons"><a class="header" href="#reading-the-buttons">Reading The Buttons</a></h2>
<p>Fun as it is to have a single static color, that's still not very exciting.</p>
<p>We can read the current state of the keys from the <code>KEYINPUT</code> control.
This includes both the "buttons" as well as the direction-pad value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub const KEYINPUT: VolAddress&lt;u16, Safe, ()&gt; =
  unsafe { VolAddress::new(0x400_0130) };
<span class="boring">}</span></code></pre></pre>
<p>Note that instead of <code>Safe</code> as the write type we've put <code>()</code> instead.
The key data is naturally read-only.
The CPU can't just tell the GBA to make a button be pressed or not, that's not gonna move the buttons.</p>
<p>With this new MMIO we can read the keys and then show a color based on the value:</p>
<pre><pre class="playground"><code class="language-rust">// in ex2.rs
#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  DISPCNT.write(0);
  loop {
    let k = KEYINPUT.read();
    BACKDROP.write(Color(k));
  }
}</code></pre></pre>
<p>Now if we run the program and press different keys we'll see the color change.</p>
<p>Each bits of <code>KEYINPUT</code> that's connected to a key will be 0 when the key is pressed and 1 when the key is released.
It's known as a "low-active" control scheme, because when a key is pressed it goes from high (1) to low (0).
Bits not connected to any key will always just be 0.
Which key controls which bit is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit</th><th style="text-align: left">Key</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">A</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">B</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">Select</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">Start</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left">Right</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left">Left</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: left">Up</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: left">Down</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: left">R</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: left">L</td></tr>
</tbody></table>
</div>
<p>Like with the color data, we probably want to make a newtype for all this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub const KEYINPUT: VolAddress&lt;KeyInput, Safe, ()&gt; =
  unsafe { VolAddress::new(0x400_0130) };

#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct KeyInput(pub u16);
#[rustfmt::skip]
impl KeyInput {
  #[inline]
  pub const fn a(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;0)) == 0 }
  #[inline]
  pub const fn b(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;1)) == 0 }
  #[inline]
  pub const fn select(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;2)) == 0 }
  #[inline]
  pub const fn start(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;3)) == 0 }
  #[inline]
  pub const fn right(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;4)) == 0 }
  #[inline]
  pub const fn left(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;5)) == 0 }
  #[inline]
  pub const fn up(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;6)) == 0 }
  #[inline]
  pub const fn down(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;7)) == 0 }
  #[inline]
  pub const fn r(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;8)) == 0 }
  #[inline]
  pub const fn l(self) -&gt; bool { (self.0 &amp; (1&lt;&lt;9)) == 0 }
}
<span class="boring">}</span></code></pre></pre>
<p>(This is kinda begging for a <code>macro_rules!</code>, but it's basically fine to put that off until later.)</p>
<p>Also let's add a definition for <code>GREEN</code> on our color type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Color {
  pub const RED: Self = Self::rgb(31, 0, 0);
  pub const GREEN: Self = Self::rgb(0, 31, 0);
  // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Now we can read the keys, and set the color to red or green based on if a key is pressed or not:</p>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  DISPCNT.write(0);
  loop {
    let k = KEYINPUT.read();
    BACKDROP.write(if k.a() { Color::RED } else { Color::GREEN })
  }
}</code></pre></pre>
<p>And I think that's enough for one article.</p>
<p><a href="https://github.com/Lokathor/gba-from-scratch/tree/72ce44550f6d8fc7072a6bd11d97334246238b5f">This</a> is the exact commit of the project files when I finished writing this article.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects--sprites"><a class="header" href="#objects--sprites">Objects / Sprites</a></h1>
<p>Now that we can get user input there's a <em>lot</em> of things that we could learn about next.
Probably we should focus on how to improve our drawing abilities.</p>
<p>Most of the GBA's drawing abilities involve either the 4 background layers, or the 128 objects (called "OBJ" for short).
The background layers let you draw a few "big" things (128x128 or bigger), and the objects let you draw many "small" things (64x64 or less).</p>
<p>The objects have a fairly consistent behavior, while the four background layers behave differently depending on the "video mode" that you set in the display control.
That's reason enough to focus on the objects first.</p>
<h3 id="are-they-objects-or-are-they-sprites"><a class="header" href="#are-they-objects-or-are-they-sprites">Are They Objects Or Are They Sprites?</a></h3>
<p>The objects are sometimes called "sprites".
GBATEK calls them objects, and mGBA (v0.10 at least) calls them sprites.
Some people care about the difference between the two terms, but I don't.
I'm just going to say "object" most of the time in this series because the data for them is called the "object active memory".</p>
<h2 id="display-control"><a class="header" href="#display-control">Display Control</a></h2>
<p>We've already seen that the display control has a "forced blank" bit.
Most of the other bits are for background control stuff, but since some of them affect object display we'll just cover that right now.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Bit(s)</th><th style="text-align: left">Setting</th></tr></thead><tbody>
<tr><td style="text-align: center">0-2</td><td style="text-align: left">Video Mode</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">(Unused in GBA mode)</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left">Frame Select</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left">Unlocked H-blank</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: left">Linear object tile mapping</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: left">Forced Blank</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: left">Enable Background 0</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: left">Enable Background 1</td></tr>
<tr><td style="text-align: center">10</td><td style="text-align: left">Enable Background 2</td></tr>
<tr><td style="text-align: center">11</td><td style="text-align: left">Enable Background 3</td></tr>
<tr><td style="text-align: center">12</td><td style="text-align: left">Enable Objects</td></tr>
<tr><td style="text-align: center">13</td><td style="text-align: left">Window 0 Display Flag</td></tr>
<tr><td style="text-align: center">14</td><td style="text-align: left">Window 1 Display Flag</td></tr>
<tr><td style="text-align: center">15</td><td style="text-align: left">OBJ Window Display Flag</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>Video Mode:</strong> This sets which mode the four background layers will operate with. Despite this being a 3-bit field, only modes 0 through 5 give a useful display. Modes 6 and 7 cause garbage output.</li>
<li><strong>Frame Select:</strong> Affects which bitmap frame is used in video mode 4 or 5.</li>
<li><strong>Unlocked H-blank:</strong> GBATEK calls this "H-Blank Interval Free", and mGBA's debug controls call this "Unlocked H-blank". This bit affects what you can do during the "horizontal blank" time between each scanline being shown, but when it's on fewer objects can be drawn. We won't be doing any per-scanline drawing for now, so we'll leave it off by default.</li>
<li><strong>Linear object tile mapping:</strong> This affects how we lay out the tiles for multi-tile objects. We'll talk about the details of this in just a moment.</li>
<li><strong>Forced Blank:</strong> Hey we know about this bit. When it's on, the display won't access any memory and will just output white pixels any time it would have rendered a pixel normally.</li>
<li><strong>Enable Background:</strong> These four bits set if we want each of the four background layers on. For now we don't care.</li>
<li><strong>Enable Objects:</strong> This bit sets the objects to be displayed.</li>
<li><strong>Window Flags:</strong> These three bits affect the "window" special graphical feature. We'll ignore these bits for now.</li>
</ul>
<p>I'm going to use the <code>bitfrob</code> crate to get some bit manipulation utilities.</p>
<pre><code>&gt; cargo add bitfrob
    Updating crates.io index
      Adding bitfrob v1.3.0 to dependencies.
             Features:
             - track_caller
    Updating crates.io index
</code></pre>
<p>Now we can give a type to our display control value, as well as just enough methods to get started.
Unlike with our <code>Color</code> type, with the <code>DisplayControl</code> we want to completely prevent an invalid video mode from being set, so we'll keep the <code>u16</code> that we're wrapping as a private field.
Then we just have one "builder" method for each bit or group of bits that we want to be able to change.
To start we can skip all the background related bits, so we'll only need three builders.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

use bitfrob::u16_with_bit;

pub const DISPCNT: VolAddress&lt;DisplayControl, Safe, Safe&gt; =
  unsafe { VolAddress::new(0x0400_0000) };

#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct DisplayControl(u16);
impl DisplayControl {
  #[inline]
  pub const fn new() -&gt; Self {
    Self(0)
  }
  #[inline]
  pub const fn with_linear_obj_tiles(self, linear: bool) -&gt; Self {
    Self(u16_with_bit(6, self.0, linear))
  }
  #[inline]
  pub const fn with_forced_blank(self, blank: bool) -&gt; Self {
    Self(u16_with_bit(7, self.0, blank))
  }
  #[inline]
  pub const fn with_objects(self, objects: bool) -&gt; Self {
    Self(u16_with_bit(12, self.0, objects))
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This will require updates to both <code>ex2.rs</code> and <code>ex3.rs</code>.</p>
<ul>
<li>For example 2, instead of writing <code>0</code> we'd write <code>DisplayControl::new()</code> instead.</li>
<li>For example 3, we want to enable object display, since we're about to start showing some objects.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// in ex3.rs

const JUST_SHOW_OBJECTS: DisplayControl =
  DisplayControl::new().with_objects(true);

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  DISPCNT.write(JUST_SHOW_OBJECTS);

  loop {
    let k = KEYINPUT.read();
    BACKDROP.write(if k.a() { Color::RED } else { Color::GREEN })
  }
}</code></pre></pre>
<p>For now that's all we need to do for the display control.</p>
<h2 id="object-palette"><a class="header" href="#object-palette">Object Palette</a></h2>
<p>Objects always need to use "paletted" color.
Instead of each pixel within the object's image holding a full color value, it just holds an index into the palette.
This allows each pixel to only need 4 or 8 bits each, instead of the 16 bits needed for a complete color.</p>
<p>The palette for objects starts at <code>0x0500_0200</code>, and it's 256 entries long.
Each object can use 8 bits per pixel (8bpp) or 4 bits per pixel (4bpp).</p>
<ul>
<li>When an object is set for 8bpp each non-zero pixel value is the 8-bit index into the object palette.
A pixel value of 0 means that the object is transparent in that pixel.
This allows for up to 255 colors to be used within a single object.</li>
<li>When an object is set for 4bpp each non-zero pixel value is <em>the low half</em> of the full index value.
A second setting within the object's attributes determine the upper half of the index value.
This effectively splits the palette memory into 16 "palbank" groupings.
As with 8bpp objects, a pixel value of 0 makes a transparent pixel.
This allows for up to 15 colors within a single object.</li>
</ul>
<p>You might notice that index 0 of the object palette isn't ever used by either mode.
The memory itself exists for consistency, but the GBA will never use the color value in that position.
Call it a free global variable for your own personal use, if you want.</p>
<p>Since we have a series of color values instead of just a single color value,
this time we'll declare the object palette as a <a href="https://docs.rs/voladdress/latest/voladdress/struct.VolBlock.html">VolBlock</a> instead of a <code>VolAddress</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub const OBJ_PALETTE: VolBlock&lt;Color, Safe, Safe, 256&gt; =
  unsafe { VolBlock::new(0x0500_0200) };
<span class="boring">}</span></code></pre></pre>
<p>A <code>VolBlock</code> works mostly like an array does.
We call <code>OBJ_PALETTE.index(i)</code> to get a particular <code>VolAddress</code>, and then we can read or write that address.
We could also use <code>get</code> if we want to do an optional lookup, or we could iterate the block, etc.</p>
<p>First let's make some more named color constants.
We'll name each of the 8 colors you get when each of the three color channels is either no-intensity or full-intensity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

impl Color {
  pub const BLACK: Self = Self::rgb(0, 0, 0);
  pub const BLUE: Self = Self::rgb(0, 0, 31);
  pub const GREEN: Self = Self::rgb(0, 31, 0);
  pub const CYAN: Self = Self::rgb(0, 31, 31);
  pub const RED: Self = Self::rgb(31, 0, 0);
  pub const MAGENTA: Self = Self::rgb(31, 0, 31);
  pub const YELLOW: Self = Self::rgb(31, 31, 0);
  pub const WHITE: Self = Self::rgb(31, 31, 31);
  // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Now we can set up a backdrop color and two different palette entries.</p>
<pre><pre class="playground"><code class="language-rust">// in ex3.rs

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(Color::MAGENTA);
  OBJ_PALETTE.index(1).write(Color::RED);
  OBJ_PALETTE.index(2).write(Color::WHITE);

  DISPCNT.write(JUST_SHOW_OBJECTS);

  loop {}
}</code></pre></pre>
<p>If we run the example in mGBA we can check our work using the debug utilities.
In the menu, "Tools -&gt; Game State Views -&gt; View Palette..." will open a dialog showing all the background and object palette info.</p>
<ul>
<li>The backdrop color will show up in the 0th entry of the background palette.</li>
<li>The two object palette colors will be in positions 1 and 2 of the top row.</li>
</ul>
<p>Each row of the palette is shown 16 colors at a time, so it's easy to tell what's happening in both 8bpp and 4bpp modes.</p>
<p>That should be enough palette setup to continue with the tutorial.</p>
<h2 id="object-tile-memory"><a class="header" href="#object-tile-memory">Object Tile Memory</a></h2>
<p>First, what is a tile exactly:</p>
<ul>
<li>A tile is an 8x8 square of palette indexes.</li>
<li>A palette index can be either 4 bits per pixel (4bpp) or 8 bits per pixel (8bpp). This is the "bit depth" of the indexes.</li>
<li>The indexes store one row at a time, left to right, top to bottom.</li>
</ul>
<p>So we might have the following Rust constants</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub const PIXELS_PER_TILE: usize = 8 * 8;
pub const BITS_PER_BYTE: usize = 8;
pub const SIZE_OF_TILE4: usize = (PIXELS_PER_TILE * 4) / BITS_PER_BYTE;
pub const SIZE_OF_TILE8: usize = (PIXELS_PER_TILE * 8) / BITS_PER_BYTE;
<span class="boring">}</span></code></pre></pre>
<p>Also, there's 32K of object tile RAM.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

macro_rules! kilobytes {
  ($bytes:expr) =&gt; {
    $bytes * 1024
  };
}

pub const SIZE_OF_OBJ_TILE_MEM: usize = kilobytes!(32);
<span class="boring">}</span></code></pre></pre>
<p>Now we know how big everything is, in bytes.
However, the GBA's video memory does <strong>NOT</strong> work right with individual byte writes.
We can cover the details another time, but with video memory you always have to write in 16-bit or 32-bit chunks.
Also, the GBA is simply much faster at transferring bulk data around when it's aligned to 4.
Data aligned to 4 can be copied one or more <code>u32</code> values at time (one or more "words" in ARM terms).
Being more aligned than 4 doesn't help any extra, but we want to have at least alignment 4 with anything big.
Tiles, particularly if we've got dozens or hundreds of them, count as "big enough to care about alignment".
This means that instead of modeling tile data as being arrays of <code>u8</code>, we'll use smaller arrays of <code>u32</code>, which will keep the data aligned to 4.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub const SIZE_OF_U32: usize = core::mem::size_of::&lt;u32&gt;();
pub const TILE4_WORD_COUNT: usize = SIZE_OF_TILE4 / SIZE_OF_U32;
pub const TILE8_WORD_COUNT: usize = SIZE_OF_TILE8 / SIZE_OF_U32;
pub const OBJ_TILE_MEM_WORD_COUNT: usize = SIZE_OF_OBJ_TILE_MEM / SIZE_OF_U32;
<span class="boring">}</span></code></pre></pre>
<p>Which lets us declare the block of <code>u32</code> values where our object tile data goes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub const OBJ_TILES_U32: VolBlock&lt;u32, Safe, Safe, OBJ_TILE_MEM_WORD_COUNT&gt; =
  unsafe { VolBlock::new(0x0601_0000) };
<span class="boring">}</span></code></pre></pre>
<p>Here's where things get kinda weird.
An object's attributes (most of which we'll cover lower down) include a "Tile ID" for the base tile of the object.
These tile id values are used as a 32 byte index, regardless of if the object uses 4bpp or 8bpp drawing.
This means that they line up perfectly with a 4bpp view of the tile data, and we get 1024 IDs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub type Tile4 = [u32; TILE4_WORD_COUNT];
pub const OBJ_TILE4: VolBlock&lt;Tile4, Safe, Safe, 1024&gt; =
  unsafe { VolBlock::new(0x0601_0000) };
<span class="boring">}</span></code></pre></pre>
<p>But with 8bpp objects we end up in a pickle.
We could use a <a href="https://docs.rs/voladdress/latest/voladdress/struct.VolSeries.html">VolSeries</a>, which is an alternative to the <code>VolBlock</code> type, for when the stride and the element size aren't the same.
The <code>VolSeries</code> type is mostly intended for when the stride is <em>bigger</em> than the element size, but the math will work out either way.
Note that since 8bpp tiles are twice as big we have to cut down the number of tiles from 1024 to 1023 so that using the last index doesn't go out of bounds.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub type Tile8 = [u32; TILE8_WORD_COUNT];
pub const OBJ_TILE8: VolSeries&lt;Tile8, Safe, Safe, 1023, 32&gt; =
  unsafe { VolSeries::new(0x0601_0000) };
<span class="boring">}</span></code></pre></pre>
<p>And, well, it looks kinda weird every time I look at the code but... that's how the hardware works.
It's the ultimate arbiter of what's correct, so sometimes you gotta just go with it.</p>
<p>We can always think about this more later, and maybe improve it then.
For now it's enough that we've got the right addresses at all.</p>
<p><strong>One final note:</strong> In video modes 3, 4, and 5 the lower half of the object tile region instead gets used as part of the background.
In this case, only object tile index values 512 and above are usable for object display.</p>
<h2 id="object-attribute-memory"><a class="header" href="#object-attribute-memory">Object Attribute Memory</a></h2>
<p>Separate from the object tile memory, there's also the Object Attribute Memory (OAM) region.
This has space for 128 "attribute" entries, which defines how the objects are shown.</p>
<p>Each attribute needs 48 bits.
This is an unfortunate number of bits, because it's not a clean power of 2.
Normally we refer to each attribute entry as having three <code>u16</code> attributes just called 0, 1, and 2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq, Eq, Default)]
#[repr(transparent)]
pub struct ObjAttr0(pub u16);

#[derive(Clone, Copy, PartialEq, Eq, Default)]
#[repr(transparent)]
pub struct ObjAttr1(pub u16);

#[derive(Clone, Copy, PartialEq, Eq, Default)]
#[repr(transparent)]
pub struct ObjAttr2(pub u16);
<span class="boring">}</span></code></pre></pre>
<p>In between each attribute entry is <em>part of</em> an affine entry.
That's right, just a part of an affine entry.
A full affine entry is four <code>i16</code> values (called A, B, C, and D).
There's one <code>i16</code> affine value per three <code>u16</code> attribute values.
The memory looks kinda like this.</p>
<ul>
<li>obj0.attr0</li>
<li>obj0.attr1</li>
<li>obj0.attr2</li>
<li>affine0.a</li>
<li>obj1.attr0</li>
<li>obj1.attr1</li>
<li>obj1.attr2</li>
<li>affine0.b</li>
<li>obj2.attr0</li>
<li>obj2.attr1</li>
<li>obj2.attr2</li>
<li>affine0.c</li>
<li>obj3.attr0</li>
<li>obj3.attr1</li>
<li>obj3.attr2</li>
<li>affine0.d</li>
</ul>
<p>And then that pattern repeats 32 times.
It's a little strange, but the hardware does what it does.</p>
<p>We can use use several <code>VolSeries</code> declarations to model this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

pub const OBJ_ATTRS_0: VolSeries&lt;ObjAttr0, Safe, Safe, 128, 64&gt; =
  unsafe { VolSeries::new(0x0700_0000) };
pub const OBJ_ATTRS_1: VolSeries&lt;ObjAttr1, Safe, Safe, 128, 64&gt; =
  unsafe { VolSeries::new(0x0700_0000 + 2) };
pub const OBJ_ATTRS_2: VolSeries&lt;ObjAttr2, Safe, Safe, 128, 64&gt; =
  unsafe { VolSeries::new(0x0700_0000 + 4) };
<span class="boring">}</span></code></pre></pre>
<p>Alternately, we could group the attributes into a single struct and view things that way.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

#[derive(Clone, Copy, PartialEq, Eq, Default)]
#[repr(C)]
pub struct ObjAttr(pub ObjAttr0, pub ObjAttr1, pub ObjAttr2);

pub const OBJ_ATTRS: VolSeries&lt;ObjAttr, Safe, Safe, 128, 64&gt; =
  unsafe { VolSeries::new(0x0700_0000) };
<span class="boring">}</span></code></pre></pre>
<p>Using the <code>ObjAttr</code> type and <code>OBJ_ATTRS</code> series would make it so that all three object attribute fields get accessed.
If you're only intending to update the position of an object (in attributes 0 and 1) without touching attribute 2, then maybe you'd care.
It's pretty unlikely to matter, but maybe.</p>
<p>Let's go over the actual properties within each object attribute field.</p>
<h3 id="object-attribute-0"><a class="header" href="#object-attribute-0">Object Attribute 0</a></h3>
<ul>
<li>Bits 0 through 7 are the Y coordinate of the <em>top-left corner</em> of the object.
The screen is 160 pixels tall, and the coordinates wrap.
If you want something to appear to move up past the top of the screen, then wrap the Y value around.
Alternately, you can do the position math using signed values and then <code>as</code> cast the value to unsigned.</li>
<li>Bits 8 and 9 set what mGBA calls the "transform" of the object:
<ul>
<li>0 is no transform.</li>
<li>1 is affine rendering. Which affine entry is used is set in attribute 1.</li>
<li>2 is no transform and the object not drawn (it's "disabled").</li>
<li>3 is just like 1 but the object is rendered with double size.</li>
</ul>
</li>
<li>Bits 10 and 11 set the special effect mode:
<ul>
<li>0 is no special effect.</li>
<li>1 is alpha blending.</li>
<li>2 is window masking. The object isn't shown, but acts as part of the object window mask.</li>
<li>3 is not allowed.</li>
</ul>
</li>
<li>Bit 12 sets if the object uses the Mosaic special effect.
This can be enabled/disabled seprately from the other effects above.</li>
<li>Bit 13 sets if the object uses 8bpp (bit set), or 4bpp (bit cleared).</li>
<li>Bits 14 and 15 set the "shape" of the object. The exact dimensions also depend on the "size" set in attribute 1
<ul>
<li>0 is square</li>
<li>1 is wider</li>
<li>2 is taller</li>
<li>3 is not allowed.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">(WxH)</th><th style="text-align: center">Size 0</th><th style="text-align: center">Size 1</th><th style="text-align: center">Size 2</th><th style="text-align: center">Size 3</th></tr></thead><tbody>
<tr><td style="text-align: center">Shape 0</td><td style="text-align: center">8x8</td><td style="text-align: center">16x16</td><td style="text-align: center">32x32</td><td style="text-align: center">64x64</td></tr>
<tr><td style="text-align: center">Shape 1</td><td style="text-align: center">16x8</td><td style="text-align: center">32x8</td><td style="text-align: center">32x16</td><td style="text-align: center">64x32</td></tr>
<tr><td style="text-align: center">Shape 2</td><td style="text-align: center">8x16</td><td style="text-align: center">8x32</td><td style="text-align: center">16x32</td><td style="text-align: center">32x64</td></tr>
</tbody></table>
</div>
<h3 id="object-attribute-1"><a class="header" href="#object-attribute-1">Object Attribute 1</a></h3>
<ul>
<li>Bits 0 through 8 are the X coordinate of the <em>top-left corner</em> of the object.
This works basically the same as with the Y coordinate, but the screen is 260 pixels wide so 9 bits are used.</li>
<li>Bits 8 through 13 depend on if the object is using affine rendering or not.
<ul>
<li>When affine (or double sized affine) rendering is used, they set the index of the affine entry used.</li>
<li>Otherwise Bit 12 sets horizontal flip and Bit 13 set vertical flip.</li>
</ul>
</li>
<li>Bits 14 and 15 set the size of the sprite.</li>
</ul>
<h3 id="object-attribute-2"><a class="header" href="#object-attribute-2">Object Attribute 2</a></h3>
<ul>
<li>Bits 0 through 9 set the base tile index of the object.
As mentioned above, in video modes 3, 4, and 5 this needs to be 512 or more.</li>
<li>Bits 10 and 11 are the "priority" value.
Lower priority objects and layers are sorted closer to the viewer, and so they are what's seen if they overlap something farther away.
Within a given priority layer, objects always draw over backgrounds, and lower index objects/backgrounds draw over higher index ones.</li>
<li>Bits 12 through 15 set the palette bank the object uses if it's using 4bpp.</li>
</ul>
<h3 id="object-rendering-time"><a class="header" href="#object-rendering-time">Object Rendering Time</a></h3>
<p>There's a limit to how many objects can be drawn per scanline, but it's not a specific number of objects.
Instead, the OAM engine has a buffer that's as wide as the screen, and there's a time limit per scanline on filling the buffer.</p>
<ul>
<li>When the "Unlocked H-blank" bit is <strong>clear</strong> in <code>DISPCNT</code> you get 1210 cycles (304 * 4 - 6)</li>
<li>When the "Unlocked H-blank" bit is <strong>set</strong> in <code>DISPCNT</code> you get 954 cycles (240 * 4 - 6)</li>
</ul>
<p>The number of cycles each object consumes depends on the object's horizontal size:</p>
<ul>
<li>Normal objects consume <code>width</code> cycles.</li>
<li>Affine objects consume <code>2 * width + 10</code> cycles.</li>
</ul>
<p>Objects are processed by their index order.
Objects not on the current scanline, horizontally/vertically off-screen, or that are "disabled" as their attribute 0 transform, are skipped in rendering but still take two cycles to process.
Even when an object won't be drawn on the current scanline the OAM engine has to look at the attributes to know that.
If not all objects are handled and time runs out then any unprocessed objects simply won't be drawn on this scanline.</p>
<h2 id="showing-static-objects"><a class="header" href="#showing-static-objects">Showing Static Objects</a></h2>
<p>Armed with all this knowledge we can probably show a static object.</p>
<p>First we want to set at least one tile in the object tile memory to some sort of pattern.
If we write a hex <code>u32</code> literal, then each digit of the hex value will be 4 bits, so we can make a 4bpp tile pretty easy.
One catch is that the indexes fill the tile from left to right, but we write numbers in code with the low-place-value digits on the right.
So our "tile" as a <code>u32</code> literal will be left-right flipped from how it'll appear on the GBA:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A tile with an extra notch on the upper left.
#[rustfmt::skip]
const TILE_UP_LEFT: [u32; 8] = [
  // Each hex digit is one 4bpp index value.
  // Also, the image is left-right flipped from how it
  // looks in code because the GBA is little-endian!
  0x11111111,
  0x12222111,
  0x12222111,
  0x12222221,
  0x12222221,
  0x12222221,
  0x12222221,
  0x11111111,
];
<span class="boring">}</span></code></pre></pre>
<p>And we can copy the data into object tile 1 in our <code>main</code> function.</p>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(Color::MAGENTA);
  OBJ_PALETTE.index(1).write(Color::RED);
  OBJ_PALETTE.index(2).write(Color::WHITE);

  OBJ_TILE4.index(1).write(TILE_UP_LEFT);

  DISPCNT.write(JUST_SHOW_OBJECTS);

  loop {}
}</code></pre></pre>
<p>We can make other similar tiles too, one for each corner notch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  OBJ_TILE4.index(1).write(TILE_UP_LEFT);
  OBJ_TILE4.index(2).write(TILE_UP_RIGHT);
  OBJ_TILE4.index(3).write(TILE_DOWN_LEFT);
  OBJ_TILE4.index(4).write(TILE_DOWN_RIGHT);
<span class="boring">}</span></code></pre></pre>
<p>If we show an 8x8 object using object tile 1, then we'll see an upper-left square.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  OBJ_ATTRS.index(0).write(ObjAttr(ObjAttr0(0), ObjAttr1(0), ObjAttr2(1)));
<span class="boring">}</span></code></pre></pre>
<p>And if we make it wider we can see an upper left and upper right square too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  OBJ_ATTRS.index(0).write(ObjAttr(
    ObjAttr0(1 &lt;&lt; 14),
    ObjAttr1(0),
    ObjAttr2(1),
  ));
<span class="boring">}</span></code></pre></pre>
<p>But when we make it taller instead, we see... just one tile?
Why isn't there a second tile drawn below the first?</p>
<p>This is that "Linear object tile mapping" flag from way back with the Display Control.
It defaults to <em>off</em>, so by default when we want to have an object more than 8 pixels tall, the next row of the object will use +32 indexes from the previous row.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // using `x + 32*y` to get the index
  OBJ_TILE4.index(1 + 32*0).write(TILE_UP_LEFT);
  OBJ_TILE4.index(2 + 32*0).write(TILE_UP_RIGHT);
  OBJ_TILE4.index(1 + 32*1).write(TILE_DOWN_LEFT);
  OBJ_TILE4.index(2 + 32*1).write(TILE_DOWN_RIGHT);
<span class="boring">}</span></code></pre></pre>
<p>Alternately, we can set up our display control to use the linear object tile system and then just fill tiles 1 to 4 like they're a normal array.</p>
<pre><pre class="playground"><code class="language-rust">const JUST_OBJECTS_LINEAR: DisplayControl =
  DisplayControl::new().with_objects(true).with_linear_obj_tiles(true);

#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(Color::MAGENTA);
  OBJ_PALETTE.index(1).write(Color::RED);
  OBJ_PALETTE.index(2).write(Color::WHITE);

  OBJ_TILE4.index(1).write(TILE_UP_LEFT);
  OBJ_TILE4.index(2).write(TILE_UP_RIGHT);
  OBJ_TILE4.index(3).write(TILE_DOWN_LEFT);
  OBJ_TILE4.index(4).write(TILE_DOWN_RIGHT);

  OBJ_ATTRS.index(0).write(ObjAttr(
    ObjAttr0(0),       // square shape
    ObjAttr1(1 &lt;&lt; 14), // size 1
    ObjAttr2(1),       // base tile 1
  ));

  DISPCNT.write(JUST_OBJECTS_LINEAR);

  loop {}
}</code></pre></pre>
<p>It's really up to you.
As long as you're consistent, either way will work.</p>
<p>Of course, also you'd want to have a lot of methods for easily getting/setting the right bits of each attribute value.
I'll put those in to <code>lib.rs</code> right now, but I'm not gonna show them all here in the tutorial text.
They all do just what you'd expect based on the <code>DisplayControl</code> type.</p>
<p>For the <code>ObjAttr</code> type we can have methods that dispatch to the correct inner field's method.
On the <code>x</code> and <code>y</code> properties we can make them take <code>i16</code> instaed of <code>u16</code> and then just cast inside the setter.
The user will probably <em>want</em> to support signed positions so that stuff can go up off the screen and left off the screen.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ObjAttr {
  #[inline]
  pub const fn new() -&gt; Self {
    Self(ObjAttr0::new(), ObjAttr1::new(), ObjAttr2::new())
  }
  #[inline]
  pub const fn with_size(self, size: u16) -&gt; Self {
    Self(self.0, self.1.with_size(size), self.2)
  }
  #[inline]
  pub const fn with_tile(self, tile: u16) -&gt; Self {
    Self(self.0, self.1, self.2.with_tile(tile))
  }
  #[inline]
  pub const fn with_x(self, x: i16) -&gt; Self {
    Self(self.0, self.1.with_x(x), self.2)
  }
  #[inline]
  pub const fn with_y(self, y: i16) -&gt; Self {
    Self(self.0.with_y(y), self.1, self.2)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>And our final <code>main</code> goes like this:</p>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub extern "C" fn main() -&gt; ! {
  BACKDROP.write(Color::MAGENTA);
  OBJ_PALETTE.index(1).write(Color::RED);
  OBJ_PALETTE.index(2).write(Color::WHITE);

  OBJ_TILE4.index(1).write(TILE_UP_LEFT);
  OBJ_TILE4.index(2).write(TILE_UP_RIGHT);
  OBJ_TILE4.index(3).write(TILE_DOWN_LEFT);
  OBJ_TILE4.index(4).write(TILE_DOWN_RIGHT);

  let obj = ObjAttr::new().with_size(1).with_tile(1).with_x(10).with_y(23);
  OBJ_ATTRS.index(0).write(obj);

  DISPCNT.write(JUST_OBJECTS_LINEAR);

  loop {}
}</code></pre></pre>
<p>which displays a little square deal thing</p>
<p><img src="ex3-working-16x16.png" alt="ex3_working_16x16" /></p>
<p>That's it for now.
Next time we'll see about making our square move around and stuff.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
