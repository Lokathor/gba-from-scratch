# Introduction

This is a series about how to program for the Game Boy Advance (GBA) using the Rust programming language.

# GBA Overview

A lot of things to do with GBA programming in one area will often slightly touch on things from another area as well.

Before trying to cover any particular subject in close detail, let's get a "high level" summary of the overall abilities and limits of the device.

## The CPU's Address Space

| Address | Region |
|:-|:-|
| `0x0000_0000` | BIOS Code |
| `0x0200_0000` | External Work RAM (EWRAM) |
| `0x0300_0000` | Internal Work RAM (IWRAM) |
| `0x0400_0000` | IO Controls |
| `0x0500_0000` | Palette RAM (PALRAM) |
| `0x0600_0000` | Video RAM (VRAM) |
| `0x0700_0000` | Object Attribute Memory (OAM) |
| `0x0800_0000` | ROM Data |
| `0x0E00_0000` | Save RAM (SRAM) |

### BIOS Code

The Basic Input/Output System (BIOS) of the GBA is part of the device itself,
rather than being part of each game cart.

A special hardware lockout system prevents the BIOS data from being read normally except when the CPU's `pc` register is pointed at the BIOS.
This allows BIOS code to execute while providing a basic level of copy protection.
Unfortunately for the designers of the GBA, there are bugs within the BIOS code that allow BIOS information to be extracted.
Various "dumps" of the BIOS data (including the disassembled code) can be found, if you need to know something exact.
However, while hardware isn't covered by copyright, software code is.
Because of that, this book won't be diving into the BIOS line by line or anything like that.

The BIOS runs some code when:
* The GBA first boots (to animate the logo, and play the boot up sound).
  After the BIOS finishes this boot sequence it transfers control to the user's program.
  For "standard" programs with one game cart this is the start of ROM.
  For "multiboot" programs this is the start of EWRAM.
  This book does not plan to cover multiboot programs, we'll be sticking to the standard setup.
* A software interrupt is generated by the running program.
  The BIOS runs the software interrupt function signalled for and then returns.
  From the program's perspective using a software interrupt works "like a function call",
  except that there's about a 60 CPU cycle overhead just for the call itself.
  Normally a function call costs only about 6 cycles on the GBA.
* A hardware interrupt is generated by one of the GBA's components.
  The BIOS partly handles the hardware interrupt,
  then it calls a "user handler" to do any additional work,
  then the user handler does whatever and returns from that call (using a normal function return),
  then the BIOS handler also returns (but using the special "interrupt return" instruction that the CPU recognizes).
  This happens "in between" two instructions somewhere in the main program.
  A hardware interrupt is *similar to, but not actually the same as* having an additional thread that exists and sometimes does work.

### External Work RAM

The EWRAM memory is a 256k byte region with no default usage.

The EWRAM has 2 wait cycles per access.
This means that a single access (read or write) takes 3 CPU cycles total: wait, wait, then the access completes.

EWRAM also only has a 16-bit bus, which means that no more than 16 bits can be transferred per access.
Accessing an 8-bit or 16-bit value can happen all at once (in 3 CPU cycles),
but accessing a 32-bit value must be split into two smaller accesses (in 6 CPU cycles total).
You don't have to worry about the splitting part, the CPU and memory chip do that totally transparently.

Still, this makes EWRAM relatively slower than program stack variables (usually in IWRAM, see below).

### Internal Work RAM

The IWRAM is 32k bytes, and has some of the bytes already allocated.

* The top 256 bytes of IWRAM are reserved.
  They are taken up by BIOS usage, and for the very small stacks used by the alternate CPU modes.
* The stack of the system/user CPU mode is also in IWRAM.
  This is what our Rust program uses (generally the Rust program runs the CPU in system mode).
  The system stack starts at `0x0300_7F00`.
  When values are pushed onto the stack, the stack pointer address *decreases*.
* The rest of IWRAM is free for you to use as you like.

IWRAM does not require any wait cycles, and has a 32-bit bus.
This means that IWRAM can be used at the full speed of the GBA's CPU (a whopping 16MHz).

It is possible to allocate both static variables and even function code into IWRAM.
The actual initialization data always lives in ROM,
but the linker can allocate values to have an IWRAM address,
then at the start of the program the appropriate data can be copied from ROM to RAM by assembly,
before any Rust code is called.
Because IWRAM isn't very large this can't be done with all your code,
but placing the "hot" code in IWRAM is commonly done.

### IO Controls

To control all of the GBA's subsystems, Memory Mapped IO (MMIO) is used.
To make a given part of the device go into whatever specific state, a specific value is written to an appropriate address.
Similarly, to get information from a part of the GBA, you read from the appropriate address.

If you've never used MMIO before, it's a little magical seeming, but it's really nothing that spooky.
When the CPU reads and writes normal memory it's "just" sending a signal along the device's data bus to the memory chip.
Using MMIO is similarly "just" sending a signal to some other chip.

To control all the part of the GBA, we "just" have to learn what addresses expect what values to be written and/or read.
There's a lot of different parts, but most of them are each fairly simple, so slow and steady will get us though.

### Palette RAM

### Video RAM

### Object Attribute Memory

### ROM Data

### Save RAM

## User Input

## Video Capabilities

The GBA's screen is 240 pixels wide and 160 pixels tall.

The pixels support Red/Green/Blue color, with 5 bits per channel.

There's 4 background layers that can use various display modes.
The GBA can also display 128 "objects" on the screen, independent of the backgrounds.
Layers and objects have a "priority" system when there's overlap, which you can think of as being the "distance" from the viewer.
Lower priority elements are "closer" and so they will be drawn when they overlap with a higher priority element.
Objects always draw over top of a background of the same priority.
When two layers or two objects have the same priority, the lower index element gets drawn.

While one of the background modes does support direct-color "bitmap" output, it takes an immense amount of CPU time to animate a full bitmap image.
Almost all GBA games are drawn using one of the indirect-color "paletted" background modes.
Paletted color on the GBA can be in either 4-bits per pixel or 8-bits per pixel.
An index value of 0 is always a "transparent" pixel, which shows the element "behind" the given pixel.
This means that 4-bit images have 15 actual colors available to them, and 8-bit images have 255 colors available.

While drawing, pixels are updated from left to right in each line, and top to bottom down the screen.
The display unit takes 4 CPU cycles to determine the color for each pixel.
After the visible 240 pixels of each line are drawn, there's also a 68-pixel "horizontal blank" before the next line begins.
After the all 160 lines are drawn, there's also a 68-line "vertical blank" period before the screen draw cycle starts over.
The entire draw loop runs at 59.73 FPS, which means that GBA games can run at "60 fps" if you round up just a tiny bit.

## Sound Capabilities

## Direct Memory Access (DMA)

## Timers

## Serial Port Communication

# Non-`cargo` Tools

## gbafix

[GitHub](https://github.com/rust-console/gbafix)

## grit

[Original Website](https://www.coranac.com/projects/grit/) (with pre-built Win32 binaries)

[Github](https://github.com/devkitPro/grit) (C source only)

# Rust Project Outline

## Cargo Configuration

## Linker Script

## `_start` fn

## Assembly Interrupt Handler

## `main` fn

# External Reference Materials

* [gbatek](https://problemkaputt.de/gbatek.htm) (html)
  This is the standard homebrew reference for all things GBA / DS / DSi related.
* [ARM Architecture Reference Manual](https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/third-party/archives/ddi0100e_arm_arm.pdf) (pdf)
  This version is published in 2000, and so covers the ARMv5T architecture.
  The GBA uses the ARMv4T architecture, which means it's covered by this document.
  Just ignore any details that they were added for v5T.
* [ARM7TDMI Reference Manual](https://documentation-service.arm.com/static/5e8e1323fd977155116a3129?token=) (pdf)
  Within the ARMv4T architecture, the GBA's exact CPU is an ARM7TDMI.
  This document can be relevent if you need close CPU details.

# Project License

The work in this project is licensed as follows:

* Rust code: `Zlib OR Apache-2.0 OR MIT`
* All other content (linker scripts, book text, etc): `CC0-1.0`

# Supporting The Project

If you'd like to support the book you can sign up to be a [Github Sponsor](https://github.com/sponsors/Lokathor).
